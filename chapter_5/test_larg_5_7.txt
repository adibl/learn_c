sprog >outfile
will write the standard output to outfile instead. If pipes are supported,
prog | anotherprog
puts the standard output of prog into the standard input of anotherprog .
Output produced by printf also finds its way to the standard output. Calls to putchar and
printf may be interleaved - output happens in the order in which the calls are made.
Each source file that refers to an input/output library function must contain the line
#include <stdio.h>
before the first reference. When the name is bracketed by < and > a search is made for the
header in a standard set of places (for example, on UNIX systems, typically in the directory
/usr/include ).
Many programs read only one input stream and write only one output stream; for such
programs, input and output with getchar , putchar , and printf may be entirely adequate,
and is certainly enough to get started. This is particularly true if redirection is used to connect
the output of one program to the input of the next. For example, consider the program lower ,
which converts its input to lower case:
#include <stdio.h>
#include <ctype.h>
main() /* lower: convert input to lower case*/
{
int c
while ((c = getchar()) != EOF)
putchar(tolower(c));
return 0;
}
The function tolower is defined in <ctype.h> ; it converts an upper case letter to lower case,
and returns other characters untouched. As we mentioned earlier, ``functions'' like getchar
and putchar in <stdio.h> and tolower in <ctype.h> are often macros, thus avoiding the
overhead of a function call per character. We will show how this is done in Section 8.5.
Regardless of how the <ctype.h> functions are implemented on a given machine, programs
that use them are shielded from knowledge of the character set.
Exercise 7-1. Write a program that converts upper case to lower or lower case to upper,
depending on the name it is invoked with, as found in argv[0] .
7.2 Formatted Output - printf
The output function printf translates internal values to characters. We have used printf
informally in previous chapters. The description here covers most typical uses but is not
complete; for the full story, see Appendix B.
int printf(char *format, arg1, arg2, ...);
printf converts, formats, and prints its arguments on the standard output under control of the
format . It returns the number of characters printed.
The format string contains two types of objects: ordinary characters, which are copied to the
output stream, and conversion specifications, each of which causes conversion and printing of
the next successive argument to printf . Each conversion specification begins with a % and
ends with a conversion character. Between the % and the conversion character there may be,
in order:126
• A minus sign, which specifies left adjustment of the converted argument.
• A number that specifies the minimum field width. The converted argument will be
printed in a field at least this wide. If necessary it will be padded on the left (or right, if
left adjustment is called for) to make up the field width.
• A period, which separates the field width from the precision.
• A number, the precision, that specifies the maximum number of characters to be printed
from a string, or the number of digits after the decimal point of a floating-point value,
or the minimum number of digits for an integer.
• An h if the integer is to be printed as a short , or l (letter ell) if as a long .
Conversion characters are shown in Table 7.1. If the character after the % is not a conversion
specification, the behavior is undefined.
Table 7.1 Basic Printf Conversions
Character
Argument type; Printed As
d,i int ; decimal number
o int ; unsigned octal number (without a leading zero)
x,X int ; unsigned hexadecimal number (without a leading 0x or 0X ), using abcdef or
ABCDEF for 10, ...,15.
u int ; unsigned decimal number
c int ; single character
s char * ; print characters from the string until a '\0' or the number of characters
f
e,E
g,G
p
%
given by the precision.
double ; [-] m.dddddd, where the number of d's is given by the precision (default
6).
double ; [-] m.dddddd e+/- xx or [-] m.dddddd E+/- xx, where the number of d's
is given by the precision (default 6).
double ; use %e or %E if the exponent is less than -4 or greater than or equal to the
precision; otherwise use %f . Trailing zeros and a trailing decimal point are not
printed.
void * ; pointer (implementation-dependent representation).
no argument is converted; print a %
A width or precision may be specified as *, in which case the value is computed by converting
the next argument (which must be an int ). For example, to print at most max characters from
a string s ,
printf("%.*s", max, s);
Most of the format conversions have been illustrated in earlier chapters. One exception is the
precision as it relates to strings. The following table shows the effect of a variety of
specifications in printing ``hello, world'' (12 characters). We have put colons around each field
so you can see it extent.
:%s:
:%10s:
:%.10s:
:%-10s:
:%.15s:
:%-15s:
:%15.10s:
:%-15.10s:
:hello, world:
:hello, world:
:hello, wor:
:hello, world:
:hello, world:
:hello, world
:
:
hello, wor:
:hello, wor
:127
A warning: printf uses its first argument to decide how many arguments follow and what
their type is. It will get confused, and you will get wrong answers, if there are not enough
arguments of if they are the wrong type. You should also be aware of the difference between
these two calls:
printf(s);
/* FAILS if s contains % */
printf("%s", s);
/* SAFE */
The function sprintf does the same conversions as printf does, but stores the output in a
string:
int sprintf(char *string, char *format, arg1, arg2, ...);
sprintf formats the arguments in arg1 , arg2 , etc., according to format as before, but places
the result in string instead of the standard output; string must be big enough to receive the
result.
Exercise 7-2. Write a program that will print arbitrary input in a sensible way. As a minimum,
it should print non-graphic characters in octal or hexadecimal according to local custom, and
break long text lines.
7.3 Variable-length Argument Lists
This section contains an implementation of a minimal version of printf , to show how to write
a function that processes a variable-length argument list in a portable way. Since we are mainly
interested in the argument processing, minprintf will process the format string and arguments
but will call the real printf to do the format conversions.
The proper declaration for printf is
int printf(char *fmt, ...)
where the declaration ... means that the number and types of these arguments may vary. The
declaration ... can only appear at the end of an argument list. Our minprintf is declared as
void minprintf(char *fmt, ...)
since we will not return the character count that printf does.
The tricky bit is how minprintf walks along the argument list when the list doesn't even have
a name. The standard header <stdarg.h> contains a set of macro definitions that define how
to step through an argument list. The implementation of this header will vary from machine to
machine, but the interface it presents is uniform.
The type va_list is used to declare a variable that will refer to each argument in turn; in
minprintf , this variable is called ap , for ``argument pointer.'' The macro va_start initializes
ap to point to the first unnamed argument. It must be called once before ap is used. There
must be at least one named argument; the final named argument is used by va_start to get
started.
Each call of va_arg returns one argument and steps ap to the next; va_arg uses a type name
to determine what type to return and how big a step to take. Finally, va_end does whatever
cleanup is necessary. It must be called before the program returns.
These properties form the basis of our simplified printf :
#include <stdarg.h>
/* minprintf: minimal printf with variable argument list */
void minprintf(char *fmt, ...)
{
va_list ap; /* points to each unnamed arg in turn */
char *p, *sval;128
int ival;
double dval;
va_start(ap, fmt); /* make ap point to 1st unnamed arg */
for (p = fmt; *p; p++) {
if (*p != '%') {
putchar(*p);
continue;
}
switch (*++p) {
case 'd':
ival = va_arg(ap, int);
printf("%d", ival);
break;
case 'f':
dval = va_arg(ap, double);
printf("%f", dval);
break;
case 's':
for (sval = va_arg(ap, char *); *sval; sval++)
putchar(*sval);
break;
default:
putchar(*p);
break;
}
}
va_end(ap); /* clean up when done */
}
Exercise 7-3. Revise minprintf to handle more of the other facilities of printf .
7.4 Formatted Input - Scanf
The function scanf is the input analog of printf , providing many of the same conversion
facilities in the opposite direction.
int scanf(char *format, ...)
scanf reads characters from the standard input, interprets them according to the specification
in format , and stores the results through the remaining arguments. The format argument is
described below; the other arguments, each of which must be a pointer, indicate where the
corresponding converted input should be stored. As with printf , this section is a summary of
the most useful features, not an exhaustive list.
scanf stops when it exhausts its format string, or when some input fails to match the control
specification. It returns as its value the number of successfully matched and assigned input
items. This can be used to decide how many items were found. On the end of file, EOF is
returned; note that this is different from 0, which means that the next input character does not
match the first specification in the format string. The next call to scanf resumes searching
immediately after the last character already converted.
There is also a function sscanf that reads from a string instead of the standard input:
int sscanf(char *string, char *format, arg1, arg2, ...)
It scans the string according to the format in format and stores the resulting values through
arg1 , arg2 , etc. These arguments must be pointers.
The format string usually contains conversion specifications, which are used to control
conversion of input. The format string may contain:
•
Blanks or tabs, which are not ignored.129
• Ordinary characters (not %), which are expected to match the next non-white space
character of the input stream.
• Conversion specifications, consisting of the character % , an optional assignment
suppression character * , an optional number specifying a maximum field width, an
optional h , l or L indicating the width of the target, and a conversion character.
A conversion specification directs the conversion of the next input field. Normally the result is
places in the variable pointed to by the corresponding argument. If assignment suppression is
indicated by the * character, however, the input field is skipped; no assignment is made. An
input field is defined as a string of non-white space characters; it extends either to the next
white space character or until the field width, is specified, is exhausted. This implies that scanf
will read across boundaries to find its input, since newlines are white space. (White space
characters are blank, tab, newline, carriage return, vertical tab, and formfeed.)
The conversion character indicates the interpretation of the input field. The corresponding
argument must be a pointer, as required by the call-by-value semantics of C. Conversion
characters are shown in Table 7.2.
Table 7.2: Basic Scanf Conversions
Character
d
i
o
u
x
c
s
e,f,g
%
Input Data; Argument type
decimal integer; int *
integer; int * . The integer may be in octal (leading 0 ) or hexadecimal (leading
0x or 0X ).
octal integer (with or without leading zero); int *
unsigned decimal integer; unsigned int *
hexadecimal integer (with or without leading 0x or 0X ); int *
characters; char * . The next input characters (default 1) are placed at the
indicated spot. The normal skip-over white space is suppressed; to read the next
non-white space character, use %1s
character string (not quoted); char * , pointing to an array of characters long
enough for the string and a terminating '\0' that will be added.
floating-point number with optional sign, optional decimal point and optional
exponent; float *
literal %; no assignment is made.
The conversion characters d , i , o , u , and x may be preceded by h to indicate that a pointer to
short rather than int appears in the argument list, or by l (letter ell) to indicate that a pointer
to long appears in the argument list.
As a first example, the rudimentary calculator of Chapter 4 can be written with scanf to do
the input conversion:
#include <stdio.h>
main() /* rudimentary calculator */
{
double sum, v;
sum = 0;
while (scanf("%lf", &v) == 1)
printf("\t%.2f\n", sum += v);
return 0;
}
Suppose we want to read input lines that contain dates of the form130
25 Dec 1988
The scanf statement is
int day, year;
char monthname[20];
scanf("%d %s %d", &day, monthname, &year);
No & is used with monthname , since an array name is a pointer.
Literal characters can appear in the scanf format string; they must match the same characters
in the input. So we could read dates of the form mm/dd/yy with the scanf statement:
int day, month, year;
scanf("%d/%d/%d", &month, &day, &year);
scanf ignores blanks and tabs in its format string. Furthermore, it skips over white space
(blanks, tabs, newlines, etc.) as it looks for input values. To read input whose format is not
fixed, it is often best to read a line at a time, then pick it apart with scanf . For example,
suppose we want to read lines that might contain a date in either of the forms above. Then we
could write
while (getline(line, sizeof(line)) > 0) {
if (sscanf(line, "%d %s %d", &day, monthname, &year) == 3)
printf("valid: %s\n", line); /* 25 Dec 1988 form */
else if (sscanf(line, "%d/%d/%d", &month, &day, &year) == 3)
printf("valid: %s\n", line); /* mm/dd/yy form */
else
printf("invalid: %s\n", line); /* invalid form */
}
Calls to scanf can be mixed with calls to other input functions. The next call to any input
function will begin by reading the first character not read by scanf .
A final warning: the arguments to scanf and sscanf must be pointers. By far the most
common error is writing
scanf("%d", n);
instead of
scanf("%d", &n);
This error is not generally detected at compile time.
Exercise 7-4. Write a private version of scanf analogous to minprintf from the previous
section.
Exercise 5-5. Rewrite the postfix calculator of Chapter 4 to use scanf and/or sscanf to do
the input and number conversion.
7.5 File Access
The examples so far have all read the standard input and written the standard output, which are
automatically defined for a program by the local operating system.
The next step is to write a program that accesses a file that is not already connected to the
program. One program that illustrates the need for such operations is cat , which concatenates
a set of named files into the standard output. cat is used for printing files on the screen, and as
a general-purpose input collector for programs that do not have the capability of accessing files
by name. For example, the command
cat x.c y.c131
prints the contents of the files x.c and y.c (and nothing else) on the standard output.
The question is how to arrange for the named files to be read - that is, how to connect the
external names that a user thinks of to the statements that read the data.
The rules are simple. Before it can be read or written, a file has to be opened by the library
function fopen . fopen takes an external name like x.c or y.c , does some housekeeping and
negotiation with the operating system (details of which needn't concern us), and returns a
pointer to be used in subsequent reads or writes of the file.
This pointer, called the file pointer, points to a structure that contains information about the
file, such as the location of a buffer, the current character position in the buffer, whether the
file is being read or written, and whether errors or end of file have occurred. Users don't need
to know the details, because the definitions obtained from <stdio.h> include a structure
declaration called FILE . The only declaration needed for a file pointer is exemplified by
FILE *fp;
FILE *fopen(char *name, char *mode);
This says that fp is a pointer to a FILE , and fopen returns a pointer to a FILE . Notice that
FILE is a type name, like int , not a structure tag; it is defined with a typedef . (Details of how
fopen can be implemented on the UNIX system are given in Section 8.5.)
The call to fopen in a program is
fp = fopen(name, mode);
The first argument of fopen is a character string containing the name of the file. The second
argument is the mode, also a character string, which indicates how one intends to use the file.
Allowable modes include read ( "r" ), write ( "w" ), and append ( "a" ). Some systems distinguish
between text and binary files; for the latter, a "b" must be appended to the mode string.
If a file that does not exist is opened for writing or appending, it is created if possible. Opening
an existing file for writing causes the old contents to be discarded, while opening for appending
preserves them. Trying to read a file that does not exist is an error, and there may be other
causes of error as well, like trying to read a file when you don't have permission. If there is any
error, fopen will return NULL . (The error can be identified more precisely; see the discussion of
error-handling functions at the end of Section 1 in Appendix B.)
The next thing needed is a way to read or write the file once it is open. getc returns the next
character from a file; it needs the file pointer to tell it which file.
int getc(FILE *fp)
getc returns the next character from the stream referred to by fp ; it returns EOF for end of file
or error.
putc is an output function:
int putc(int c, FILE *fp)
putc writes the character c to the file fp and returns the character written, or EOF if an error
occurs. Like getchar and putchar , getc and putc may be macros instead of functions.
When a C program is started, the operating system environment is responsible for opening
three files and providing pointers for them. These files are the standard input, the standard
output, and the standard error; the corresponding file pointers are called stdin , stdout , and
stderr , and are declared in <stdio.h> . Normally stdin is connected to the keyboard and
stdout and stderr are connected to the screen, but stdin and stdout may be redirected to
files or pipes as described in Section 7.1.132
getchar and putchar can be defined in terms of getc , putc , stdin , and stdout as follows:
#define getchar()
#define putchar(c)
getc(stdin)
putc((c), stdout)
For formatted input or output of files, the functions fscanf and fprintf may be used. These
are identical to scanf and printf , except that the first argument is a file pointer that specifies
the file to be read or written; the format string is the second argument.
int fscanf(FILE *fp, char *format, ...)
int fprintf(FILE *fp, char *format, ...)
With these preliminaries out of the way, we are now in a position to write the program cat to
concatenate files. The design is one that has been found convenient for many programs. If
there are command-line arguments, they are interpreted as filenames, and processed in order. If
there are no arguments, the standard input is processed.
#include <stdio.h>
/* cat:
main(int
{
FILE
void
concatenate files, version 1 */
argc, char *argv[])
*fp;
filecopy(FILE *, FILE *)
if (argc == 1) /* no args; copy standard input */
filecopy(stdin, stdout);
else
while(--argc > 0)
if ((fp = fopen(*++argv, "r")) == NULL) {
printf("cat: can't open %s\n, *argv);
return 1;
} else {
filecopy(fp, stdout);
fclose(fp);
}
return 0;
}
/* filecopy: copy file ifp to file ofp */
void filecopy(FILE *ifp, FILE *ofp)
{
int c;
while ((c = getc(ifp)) != EOF)
putc(c, ofp);
}
The file pointers stdin and stdout are objects of type FILE * . They are constants, however,
not variables, so it is not possible to assign to them.
The function
int fclose(FILE *fp)
is the inverse of fopen , it breaks the connection between the file pointer and the external name
that was established by fopen , freeing the file pointer for another file. Since most operating
systems have some limit on the number of files that a program may have open simultaneously,
it's a good idea to free the file pointers when they are no longer needed, as we did in cat .
There is also another reason for fclose on an output file - it flushes the buffer in which putc
is collecting output. fclose is called automatically for each open file when a program
terminates normally. (You can close stdin and stdout if they are not needed. They can also
be reassigned by the library function freopen .)
7.6 Error Handling - Stderr and Exit133
The treatment of errors in cat is not ideal. The trouble is that if one of the files can't be
accessed for some reason, the diagnostic is printed at the end of the concatenated output. That
might be acceptable if the output is going to a screen, but not if it's going into a file or into
another program via a pipeline.
To handle this situation better, a second output stream, called stderr , is assigned to a
program in the same way that stdin and stdout are. Output written on stderr normally
appears on the screen even if the standard output is redirected.
Let us revise cat to write its error messages on the standard error.
#include <stdio.h>
/* cat:
main(int
{
FILE
void
char
concatenate files, version 2 */
argc, char *argv[])
*fp;
filecopy(FILE *, FILE *);
*prog = argv[0]; /* program name for errors */
if (argc == 1 ) /* no args; copy standard input */
filecopy(stdin, stdout);
else
while (--argc > 0)
if ((fp = fopen(*++argv, "r")) == NULL) {
fprintf(stderr, "%s: can't open %s\n",
prog, *argv);
exit(1);
} else {
filecopy(fp, stdout);
fclose(fp);
}
if (ferror(stdout)) {
fprintf(stderr, "%s: error writing stdout\n", prog);
exit(2);
}
exit(0);
}
The program signals errors in two ways. First, the diagnostic output produced by fprintf
goes to stderr , so it finds its way to the screen instead of disappearing down a pipeline or into
an output file. We included the program name, from argv[0] , in the message, so if this
program is used with others, the source of an error is identified.
Second, the program uses the standard library function exit , which terminates program
execution when it is called. The argument of exit is available to whatever process called this
one, so the success or failure of the program can be tested by another program that uses this
one as a sub-process. Conventionally, a return value of 0 signals that all is well; non-zero
values usually signal abnormal situations. exit calls fclose for each open output file, to flush
out any buffered output.
Within main , return expr is equivalent to exit (expr). exit has the advantage that it can be
called from other functions, and that calls to it can be found with a pattern-searching program
like those in Chapter 5.
The function ferror returns non-zero if an error occurred on the stream fp .prog >outfile
will write the standard output to outfile instead. If pipes are supported,
prog | anotherprog
puts the standard output of prog into the standard input of anotherprog .
Output produced by printf also finds its way to the standard output. Calls to putchar and
printf may be interleaved - output happens in the order in which the calls are made.
Each source file that refers to an input/output library function must contain the line
#include <stdio.h>
before the first reference. When the name is bracketed by < and > a search is made for the
header in a standard set of places (for example, on UNIX systems, typically in the directory
/usr/include ).
Many programs read only one input stream and write only one output stream; for such
programs, input and output with getchar , putchar , and printf may be entirely adequate,
and is certainly enough to get started. This is particularly true if redirection is used to connect
the output of one program to the input of the next. For example, consider the program lower ,
which converts its input to lower case:
#include <stdio.h>
#include <ctype.h>
main() /* lower: convert input to lower case*/
{
int c
while ((c = getchar()) != EOF)
putchar(tolower(c));
return 0;
}
The function tolower is defined in <ctype.h> ; it converts an upper case letter to lower case,
and returns other characters untouched. As we mentioned earlier, ``functions'' like getchar
and putchar in <stdio.h> and tolower in <ctype.h> are often macros, thus avoiding the
overhead of a function call per character. We will show how this is done in Section 8.5.
Regardless of how the <ctype.h> functions are implemented on a given machine, programs
that use them are shielded from knowledge of the character set.
Exercise 7-1. Write a program that converts upper case to lower or lower case to upper,
depending on the name it is invoked with, as found in argv[0] .
7.2 Formatted Output - printf
The output function printf translates internal values to characters. We have used printf
informally in previous chapters. The description here covers most typical uses but is not
complete; for the full story, see Appendix B.
int printf(char *format, arg1, arg2, ...);
printf converts, formats, and prints its arguments on the standard output under control of the
format . It returns the number of characters printed.
The format string contains two types of objects: ordinary characters, which are copied to the
output stream, and conversion specifications, each of which causes conversion and printing of
the next successive argument to printf . Each conversion specification begins with a % and
ends with a conversion character. Between the % and the conversion character there may be,
in order:126
• A minus sign, which specifies left adjustment of the converted argument.
• A number that specifies the minimum field width. The converted argument will be
printed in a field at least this wide. If necessary it will be padded on the left (or right, if
left adjustment is called for) to make up the field width.
• A period, which separates the field width from the precision.
• A number, the precision, that specifies the maximum number of characters to be printed
from a string, or the number of digits after the decimal point of a floating-point value,
or the minimum number of digits for an integer.
• An h if the integer is to be printed as a short , or l (letter ell) if as a long .
Conversion characters are shown in Table 7.1. If the character after the % is not a conversion
specification, the behavior is undefined.
Table 7.1 Basic Printf Conversions
Character
Argument type; Printed As
d,i int ; decimal number
o int ; unsigned octal number (without a leading zero)
x,X int ; unsigned hexadecimal number (without a leading 0x or 0X ), using abcdef or
ABCDEF for 10, ...,15.
u int ; unsigned decimal number
c int ; single character
s char * ; print characters from the string until a '\0' or the number of characters
f
e,E
g,G
p
%
given by the precision.
double ; [-] m.dddddd, where the number of d's is given by the precision (default
6).
double ; [-] m.dddddd e+/- xx or [-] m.dddddd E+/- xx, where the number of d's
is given by the precision (default 6).
double ; use %e or %E if the exponent is less than -4 or greater than or equal to the
precision; otherwise use %f . Trailing zeros and a trailing decimal point are not
printed.
void * ; pointer (implementation-dependent representation).
no argument is converted; print a %
A width or precision may be specified as *, in which case the value is computed by converting
the next argument (which must be an int ). For example, to print at most max characters from
a string s ,
printf("%.*s", max, s);
Most of the format conversions have been illustrated in earlier chapters. One exception is the
precision as it relates to strings. The following table shows the effect of a variety of
specifications in printing ``hello, world'' (12 characters). We have put colons around each field
so you can see it extent.
:%s:
:%10s:
:%.10s:
:%-10s:
:%.15s:
:%-15s:
:%15.10s:
:%-15.10s:
:hello, world:
:hello, world:
:hello, wor:
:hello, world:
:hello, world:
:hello, world
:
:
hello, wor:
:hello, wor
:127
A warning: printf uses its first argument to decide how many arguments follow and what
their type is. It will get confused, and you will get wrong answers, if there are not enough
arguments of if they are the wrong type. You should also be aware of the difference between
these two calls:
printf(s);
/* FAILS if s contains % */
printf("%s", s);
/* SAFE */
The function sprintf does the same conversions as printf does, but stores the output in a
string:
int sprintf(char *string, char *format, arg1, arg2, ...);
sprintf formats the arguments in arg1 , arg2 , etc., according to format as before, but places
the result in string instead of the standard output; string must be big enough to receive the
result.
Exercise 7-2. Write a program that will print arbitrary input in a sensible way. As a minimum,
it should print non-graphic characters in octal or hexadecimal according to local custom, and
break long text lines.
7.3 Variable-length Argument Lists
This section contains an implementation of a minimal version of printf , to show how to write
a function that processes a variable-length argument list in a portable way. Since we are mainly
interested in the argument processing, minprintf will process the format string and arguments
but will call the real printf to do the format conversions.
The proper declaration for printf is
int printf(char *fmt, ...)
where the declaration ... means that the number and types of these arguments may vary. The
declaration ... can only appear at the end of an argument list. Our minprintf is declared as
void minprintf(char *fmt, ...)
since we will not return the character count that printf does.
The tricky bit is how minprintf walks along the argument list when the list doesn't even have
a name. The standard header <stdarg.h> contains a set of macro definitions that define how
to step through an argument list. The implementation of this header will vary from machine to
machine, but the interface it presents is uniform.
The type va_list is used to declare a variable that will refer to each argument in turn; in
minprintf , this variable is called ap , for ``argument pointer.'' The macro va_start initializes
ap to point to the first unnamed argument. It must be called once before ap is used. There
must be at least one named argument; the final named argument is used by va_start to get
started.
Each call of va_arg returns one argument and steps ap to the next; va_arg uses a type name
to determine what type to return and how big a step to take. Finally, va_end does whatever
cleanup is necessary. It must be called before the program returns.
These properties form the basis of our simplified printf :
#include <stdarg.h>
/* minprintf: minimal printf with variable argument list */
void minprintf(char *fmt, ...)
{
va_list ap; /* points to each unnamed arg in turn */
char *p, *sval;128
int ival;
double dval;
va_start(ap, fmt); /* make ap point to 1st unnamed arg */
for (p = fmt; *p; p++) {
if (*p != '%') {
putchar(*p);
continue;
}
switch (*++p) {
case 'd':
ival = va_arg(ap, int);
printf("%d", ival);
break;
case 'f':
dval = va_arg(ap, double);
printf("%f", dval);
break;
case 's':
for (sval = va_arg(ap, char *); *sval; sval++)
putchar(*sval);
break;
default:
putchar(*p);
break;
}
}
va_end(ap); /* clean up when done */
}
Exercise 7-3. Revise minprintf to handle more of the other facilities of printf .
7.4 Formatted Input - Scanf
The function scanf is the input analog of printf , providing many of the same conversion
facilities in the opposite direction.
int scanf(char *format, ...)
scanf reads characters from the standard input, interprets them according to the specification
in format , and stores the results through the remaining arguments. The format argument is
described below; the other arguments, each of which must be a pointer, indicate where the
corresponding converted input should be stored. As with printf , this section is a summary of
the most useful features, not an exhaustive list.
scanf stops when it exhausts its format string, or when some input fails to match the control
specification. It returns as its value the number of successfully matched and assigned input
items. This can be used to decide how many items were found. On the end of file, EOF is
returned; note that this is different from 0, which means that the next input character does not
match the first specification in the format string. The next call to scanf resumes searching
immediately after the last character already converted.
There is also a function sscanf that reads from a string instead of the standard input:
int sscanf(char *string, char *format, arg1, arg2, ...)
It scans the string according to the format in format and stores the resulting values through
arg1 , arg2 , etc. These arguments must be pointers.
The format string usually contains conversion specifications, which are used to control
conversion of input. The format string may contain:
•
Blanks or tabs, which are not ignored.129
• Ordinary characters (not %), which are expected to match the next non-white space
character of the input stream.
• Conversion specifications, consisting of the character % , an optional assignment
suppression character * , an optional number specifying a maximum field width, an
optional h , l or L indicating the width of the target, and a conversion character.
A conversion specification directs the conversion of the next input field. Normally the result is
places in the variable pointed to by the corresponding argument. If assignment suppression is
indicated by the * character, however, the input field is skipped; no assignment is made. An
input field is defined as a string of non-white space characters; it extends either to the next
white space character or until the field width, is specified, is exhausted. This implies that scanf
will read across boundaries to find its input, since newlines are white space. (White space
characters are blank, tab, newline, carriage return, vertical tab, and formfeed.)
The conversion character indicates the interpretation of the input field. The corresponding
argument must be a pointer, as required by the call-by-value semantics of C. Conversion
characters are shown in Table 7.2.
Table 7.2: Basic Scanf Conversions
Character
d
i
o
u
x
c
s
e,f,g
%
Input Data; Argument type
decimal integer; int *
integer; int * . The integer may be in octal (leading 0 ) or hexadecimal (leading
0x or 0X ).
octal integer (with or without leading zero); int *
unsigned decimal integer; unsigned int *
hexadecimal integer (with or without leading 0x or 0X ); int *
characters; char * . The next input characters (default 1) are placed at the
indicated spot. The normal skip-over white space is suppressed; to read the next
non-white space character, use %1s
character string (not quoted); char * , pointing to an array of characters long
enough for the string and a terminating '\0' that will be added.
floating-point number with optional sign, optional decimal point and optional
exponent; float *
literal %; no assignment is made.
The conversion characters d , i , o , u , and x may be preceded by h to indicate that a pointer to
short rather than int appears in the argument list, or by l (letter ell) to indicate that a pointer
to long appears in the argument list.
As a first example, the rudimentary calculator of Chapter 4 can be written with scanf to do
the input conversion:
#include <stdio.h>
main() /* rudimentary calculator */
{
double sum, v;
sum = 0;
while (scanf("%lf", &v) == 1)
printf("\t%.2f\n", sum += v);
return 0;
}
Suppose we want to read input lines that contain dates of the form130
25 Dec 1988
The scanf statement is
int day, year;
char monthname[20];
scanf("%d %s %d", &day, monthname, &year);
No & is used with monthname , since an array name is a pointer.
Literal characters can appear in the scanf format string; they must match the same characters
in the input. So we could read dates of the form mm/dd/yy with the scanf statement:
int day, month, year;
scanf("%d/%d/%d", &month, &day, &year);
scanf ignores blanks and tabs in its format string. Furthermore, it skips over white space
(blanks, tabs, newlines, etc.) as it looks for input values. To read input whose format is not
fixed, it is often best to read a line at a time, then pick it apart with scanf . For example,
suppose we want to read lines that might contain a date in either of the forms above. Then we
could write
while (getline(line, sizeof(line)) > 0) {
if (sscanf(line, "%d %s %d", &day, monthname, &year) == 3)
printf("valid: %s\n", line); /* 25 Dec 1988 form */
else if (sscanf(line, "%d/%d/%d", &month, &day, &year) == 3)
printf("valid: %s\n", line); /* mm/dd/yy form */
else
printf("invalid: %s\n", line); /* invalid form */
}
Calls to scanf can be mixed with calls to other input functions. The next call to any input
function will begin by reading the first character not read by scanf .
A final warning: the arguments to scanf and sscanf must be pointers. By far the most
common error is writing
scanf("%d", n);
instead of
scanf("%d", &n);
This error is not generally detected at compile time.
Exercise 7-4. Write a private version of scanf analogous to minprintf from the previous
section.
Exercise 5-5. Rewrite the postfix calculator of Chapter 4 to use scanf and/or sscanf to do
the input and number conversion.
7.5 File Access
The examples so far have all read the standard input and written the standard output, which are
automatically defined for a program by the local operating system.
The next step is to write a program that accesses a file that is not already connected to the
program. One program that illustrates the need for such operations is cat , which concatenates
a set of named files into the standard output. cat is used for printing files on the screen, and as
a general-purpose input collector for programs that do not have the capability of accessing files
by name. For example, the command
cat x.c y.c131
prints the contents of the files x.c and y.c (and nothing else) on the standard output.
The question is how to arrange for the named files to be read - that is, how to connect the
external names that a user thinks of to the statements that read the data.
The rules are simple. Before it can be read or written, a file has to be opened by the library
function fopen . fopen takes an external name like x.c or y.c , does some housekeeping and
negotiation with the operating system (details of which needn't concern us), and returns a
pointer to be used in subsequent reads or writes of the file.
This pointer, called the file pointer, points to a structure that contains information about the
file, such as the location of a buffer, the current character position in the buffer, whether the
file is being read or written, and whether errors or end of file have occurred. Users don't need
to know the details, because the definitions obtained from <stdio.h> include a structure
declaration called FILE . The only declaration needed for a file pointer is exemplified by
FILE *fp;
FILE *fopen(char *name, char *mode);
This says that fp is a pointer to a FILE , and fopen returns a pointer to a FILE . Notice that
FILE is a type name, like int , not a structure tag; it is defined with a typedef . (Details of how
fopen can be implemented on the UNIX system are given in Section 8.5.)
The call to fopen in a program is
fp = fopen(name, mode);
The first argument of fopen is a character string containing the name of the file. The second
argument is the mode, also a character string, which indicates how one intends to use the file.
Allowable modes include read ( "r" ), write ( "w" ), and append ( "a" ). Some systems distinguish
between text and binary files; for the latter, a "b" must be appended to the mode string.
If a file that does not exist is opened for writing or appending, it is created if possible. Opening
an existing file for writing causes the old contents to be discarded, while opening for appending
preserves them. Trying to read a file that does not exist is an error, and there may be other
causes of error as well, like trying to read a file when you don't have permission. If there is any
error, fopen will return NULL . (The error can be identified more precisely; see the discussion of
error-handling functions at the end of Section 1 in Appendix B.)
The next thing needed is a way to read or write the file once it is open. getc returns the next
character from a file; it needs the file pointer to tell it which file.
int getc(FILE *fp)
getc returns the next character from the stream referred to by fp ; it returns EOF for end of file
or error.
putc is an output function:
int putc(int c, FILE *fp)
putc writes the character c to the file fp and returns the character written, or EOF if an error
occurs. Like getchar and putchar , getc and putc may be macros instead of functions.
When a C program is started, the operating system environment is responsible for opening
three files and providing pointers for them. These files are the standard input, the standard
output, and the standard error; the corresponding file pointers are called stdin , stdout , and
stderr , and are declared in <stdio.h> . Normally stdin is connected to the keyboard and
stdout and stderr are connected to the screen, but stdin and stdout may be redirected to
files or pipes as described in Section 7.1.132
getchar and putchar can be defined in terms of getc , putc , stdin , and stdout as follows:
#define getchar()
#define putchar(c)
getc(stdin)
putc((c), stdout)
For formatted input or output of files, the functions fscanf and fprintf may be used. These
are identical to scanf and printf , except that the first argument is a file pointer that specifies
the file to be read or written; the format string is the second argument.
int fscanf(FILE *fp, char *format, ...)
int fprintf(FILE *fp, char *format, ...)
With these preliminaries out of the way, we are now in a position to write the program cat to
concatenate files. The design is one that has been found convenient for many programs. If
there are command-line arguments, they are interpreted as filenames, and processed in order. If
there are no arguments, the standard input is processed.
#include <stdio.h>
/* cat:
main(int
{
FILE
void
concatenate files, version 1 */
argc, char *argv[])
*fp;
filecopy(FILE *, FILE *)
if (argc == 1) /* no args; copy standard input */
filecopy(stdin, stdout);
else
while(--argc > 0)
if ((fp = fopen(*++argv, "r")) == NULL) {
printf("cat: can't open %s\n, *argv);
return 1;
} else {
filecopy(fp, stdout);
fclose(fp);
}
return 0;
}
/* filecopy: copy file ifp to file ofp */
void filecopy(FILE *ifp, FILE *ofp)
{
int c;
while ((c = getc(ifp)) != EOF)
putc(c, ofp);
}
The file pointers stdin and stdout are objects of type FILE * . They are constants, however,
not variables, so it is not possible to assign to them.
The function
int fclose(FILE *fp)
is the inverse of fopen , it breaks the connection between the file pointer and the external name
that was established by fopen , freeing the file pointer for another file. Since most operating
systems have some limit on the number of files that a program may have open simultaneously,
it's a good idea to free the file pointers when they are no longer needed, as we did in cat .
There is also another reason for fclose on an output file - it flushes the buffer in which putc
is collecting output. fclose is called automatically for each open file when a program
terminates normally. (You can close stdin and stdout if they are not needed. They can also
be reassigned by the library function freopen .)
7.6 Error Handling - Stderr and Exit133
The treatment of errors in cat is not ideal. The trouble is that if one of the files can't be
accessed for some reason, the diagnostic is printed at the end of the concatenated output. That
might be acceptable if the output is going to a screen, but not if it's going into a file or into
another program via a pipeline.
To handle this situation better, a second output stream, called stderr , is assigned to a
program in the same way that stdin and stdout are. Output written on stderr normally
appears on the screen even if the standard output is redirected.
Let us revise cat to write its error messages on the standard error.
#include <stdio.h>
/* cat:
main(int
{
FILE
void
char
concatenate files, version 2 */
argc, char *argv[])
*fp;
filecopy(FILE *, FILE *);
*prog = argv[0]; /* program name for errors */
if (argc == 1 ) /* no args; copy standard input */
filecopy(stdin, stdout);
else
while (--argc > 0)
if ((fp = fopen(*++argv, "r")) == NULL) {
fprintf(stderr, "%s: can't open %s\n",
prog, *argv);
exit(1);
} else {
filecopy(fp, stdout);
fclose(fp);
}
if (ferror(stdout)) {
fprintf(stderr, "%s: error writing stdout\n", prog);
exit(2);
}
exit(0);
}
The program signals errors in two ways. First, the diagnostic output produced by fprintf
goes to stderr , so it finds its way to the screen instead of disappearing down a pipeline or into
an output file. We included the program name, from argv[0] , in the message, so if this
program is used with others, the source of an error is identified.
Second, the program uses the standard library function exit , which terminates program
execution when it is called. The argument of exit is available to whatever process called this
one, so the success or failure of the program can be tested by another program that uses this
one as a sub-process. Conventionally, a return value of 0 signals that all is well; non-zero
values usually signal abnormal situations. exit calls fclose for each open output file, to flush
out any buffered output.
Within main , return expr is equivalent to exit (expr). exit has the advantage that it can be
called from other functions, and that calls to it can be found with a pattern-searching program
like those in Chapter 5.
The function ferror returns non-zero if an error occurred on the stream fp .fsdSince any individual element of v (alias lineptr ) is a character pointer, temp must be also, so
one can be copied to the other.
Exercise 5-7. Rewrite readlines to store lines in an array supplied by main , rather than
calling alloc to maintain storage. How much faster is the program?
5.7 Multi-dimensional Arrays
C provides rectangular multi-dimensional arrays, although in practice they are much less used
than arrays of pointers. In this section, we will show some of their properties.
Consider the problem of date conversion, from day of the month to day of the year and vice
versa. For example, March 1 is the 60th day of a non-leap year, and the 61st day of a leap year.
Let us define two functions to do the conversions: day_of_year converts the month and day
into the day of the year, and month_day converts the day of the year into the month and day.
Since this latter function computes two values, the month and day arguments will be pointers:
month_day(1988, 60, &m, &d)
sets m to 2 and d to 29 (February 29th).
These functions both need the same information, a table of the number of days in each month
(``thirty days hath September ...''). Since the number of days per month differs for leap years
and non-leap years, it's easier to separate them into two rows of a two-dimensional array than
to keep track of what happens to February during computation. The array and the functions for
Recall that the arithmetic value of a logical expression, such as the one for leap , is either zero
(false) or one (true), so it can be used as a subscript of the array daytab .
The array daytab has to be external to both day_of_year and month_day , so they can both
use it. We made it char to illustrate a legitimate use of char for storing small non-character
integers.
daytab is the first two-dimensional array we have dealt with. In C, a two-dimensional array is
really a one-dimensional array, each of whose elements is an array. Hence subscripts are
written as
daytab[i][j]
/* [row][col] */
rather than
daytab[i,j]
/* WRONG */
Other than this notational distinction, a two-dimensional array can be treated in much the same
way as in other languages. Elements are stored by rows, so the rightmost subscript, or column,
varies fastest as elements are accessed in storage order.
An array is initialized by a list of initializers in braces; each row of a two-dimensional array is
initialized by a corresponding sub-list. We started the array daytab with a column of zero so
that month numbers can run from the natural 1 to 12 instead of 0 to 11. Since space is not at a
premium here, this is clearer than adjusting the indices.
If a two-dimensional array is to be passed to a function, the parameter declaration in the
function must include the number of columns; the number of rows is irrelevant, since what is
passed is, as before, a pointer to an array of rows, where each row is an array of 13 int s. In
this particular case, it is a pointer to objects that are arrays of 13 int s. Thus if the array
daytab is to be passed to a function f , the declaration of f would be:
It could also be
f(int daytab[][13]) { ... }
since the number of rows is irrelevant, or it could be
f(int (*daytab)[13]) { ... }
which says that the parameter is a pointer to an array of 13 integers. The parentheses are
necessary since brackets [] have higher precedence than * . Without parentheses, the
declaration
int *daytab[13]
is an array of 13 pointers to integers. More generally, only the first dimension (subscript) of an
array is free; all the others have to be specified.
Section 5.12 has a further discussion of complicated declarations.
Exercise 5-8. There is no error checking in day_of_year or month_day . Remedy this defect.
5.8 Initialization of Pointer Arraysperforming the transformations are as follows:
since the number of rows is irrelevant, or it could be
f(int (*daytab)[13]) { ... }
which says that the parameter is a pointer to an array of 13 integers. The parentheses are
necessary since brackets [] have higher precedence than * . Without parentheses, the
declaration
int *daytab[13]
is an array of 13 pointers to integers. More generally, only the first dimension (subscript) of an
array is free; all the others have to be specified.
Section 5.12 has a further discussion of complicated declarations.
Exercise 5-8. There is no error checking in day_of_year or month_day . Remedy this defect.
5.8 Initialization of Pointer Arrays94
Consider the problem of writing a function month_name(n) , which returns a pointer to a
character string containing the name of the n -th month. This is an ideal application for an
internal static array. month_name contains a private array of character strings, and returns a
pointer to the proper one when called. This section shows how that array of names is
initialized.
The syntax is similar to previous initializations:
/* month_name: return name of n-th month */
char *month_name(int n)
{
static char *name[] = {
"Illegal month",
"January", "February", "March",
"April", "May", "June",
"July", "August", "September",
"October", "November", "December"
};
return (n < 1 || n > 12) ? name[0] : name[n];
}
The declaration of name , which is an array of character pointers, is the same as lineptr in the
sorting example. The initializer is a list of character strings; each is assigned to the
corresponding position in the array. The characters of the i -th string are placed somewhere,
and a pointer to them is stored in name[i] . Since the size of the array name is not specified,
the compiler counts the initializers and fills in the correct number.
5.9 Pointers vs. Multi-dimensional Arrays
Newcomers to C are sometimes confused about the difference between a two-dimensional
array and an array of pointers, such as name in the example above. Given the definitions
int a[10][20];
int *b[10];
then a[3][4] and b[3][4] are both syntactically legal references to a single int . But a is a
true two-dimensional array: 200 int -sized locations have been set aside, and the conventional
rectangular subscript calculation 20 * row +col is used to find the element a[row,col] . For b ,
however, the definition only allocates 10 pointers and does not initialize them; initialization
must be done explicitly, either statically or with code. Assuming that each element of b does
point to a twenty-element array, then there will be 200 int s set aside, plus ten cells for the
pointers. The important advantage of the pointer array is that the rows of the array may be of
different lengths. That is, each element of b need not point to a twenty-element vector; some
may point to two elements, some to fifty, and some to none at all.
Although we have phrased this discussion in terms of integers, by far the most frequent use of
arrays of pointers is to store character strings of diverse lengths, as in the function
month_name . Compare the declaration and picture for an array of pointers:
char *name[] = { "Illegal month", "Jan", "Feb", "Mar" };95
with those for a two-dimensional array:
char aname[][15] = { "Illegal month", "Jan", "Feb", "Mar" };
Exercise 5-9. Rewrite the routines day_of_year and month_day with pointers instead of
indexing.
5.10 Command-line Arguments
In environments that support C, there is a way to pass command-line arguments or parameters
to a program when it begins executing. When main is called, it is called with two arguments.
The first (conventionally called argc , for argument count) is the number of command-line
arguments the program was invoked with; the second ( argv , for argument vector) is a pointer
to an array of character strings that contain the arguments, one per string. We customarily use
multiple levels of pointers to manipulate these character strings.
The simplest illustration is the program echo , which echoes its command-line arguments on a
single line, separated by blanks. That is, the command
echo hello, world
prints the output
hello, world
By convention, argv[0] is the name by which the program was invoked, so argc is at least 1.
If argc is 1, there are no command-line arguments after the program name. In the example
above, argc is 3, and argv[0] , argv[1] , and argv[2] are "echo" , "hello," , and "world"
respectively. The first optional argument is argv[1] and the last is argv[argc-1] ;
additionally, the standard requires that argv[argc] be a null pointer.
The first version of echo treats argv as an array of character pointers:
#include <stdio.h>
/* echo command-line arguments; 1st version */
main(int argc, char *argv[])
{
int i;
for (i = 1; i < argc; i++)
printf("%s%s", argv[i], (i < argc-1) ? " " : "");
printf("\n");
return 0;96
}
Since argv is a pointer to an array of pointers, we can manipulate the pointer rather than index
the array. This next variant is based on incrementing argv , which is a pointer to pointer to
char , while argc is counted down:
#include <stdio.h>
/* echo command-line arguments; 2nd version */
main(int argc, char *argv[])
{
while (--argc > 0)
printf("%s%s", *++argv, (argc > 1) ? " " : "");
printf("\n");
return 0;
}
Since argv is a pointer to the beginning of the array of argument strings, incrementing it by 1
( ++argv ) makes it point at the original argv[1] instead of argv[0] . Each successive
increment moves it along to the next argument; *argv is then the pointer to that argument. At
the same time, argc is decremented; when it becomes zero, there are no arguments left to
print.
Alternatively, we could write the printf statement as
printf((argc > 1) ? "%s " : "%s", *++argv);
This shows that the format argument of printf can be an expression too.
As a second example, let us make some enhancements to the pattern-finding program from
Section 4.1. If you recall, we wired the search pattern deep into the program, an obviously
unsatisfactory arrangement. Following the lead of the UNIX program grep , let us enhance the
program so the pattern to be matched is specified by the first argument on the command line.
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000
int getline(char *line, int max);
/* find: print lines that match pattern from 1st arg */
main(int argc, char *argv[])
{
char line[MAXLINE];
int found = 0;
if (argc != 2)
printf("Usage: find pattern\n");
else
while (getline(line, MAXLINE) > 0)
if (strstr(line, argv[1]) != NULL) {
printf("%s", line);
found++;
}
return found;
}
The standard library function strstr(s,t) returns a pointer to the first occurrence of the
string t in the string s , or NULL if there is none. It is declared in <string.h> .
The model can now be elaborated to illustrate further pointer constructions. Suppose we want
to allow two optional arguments. One says ``print all the lines except those that match the
pattern;'' the second says ``precede each printed line by its line number.''97
A common convention for C programs on UNIX systems is that an argument that begins with
a minus sign introduces an optional flag or parameter. If we choose -x (for ``except'') to signal
the inversion, and -n (``number'') to request line numbering, then the command
find -x -npattern
will print each line that doesn't match the pattern, preceded by its line number.
Optional arguments should be permitted in any order, and the rest of the program should be
independent of the number of arguments that we present. Furthermore, it is convenient for
users if option arguments can be combined, as in
find -nx pattern
Here is the program:
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000
int getline(char *line, int max);
/* find: print lines that match pattern from 1st arg */
main(int argc, char *argv[])
{
char line[MAXLINE];
long lineno = 0;
int c, except = 0, number = 0, found = 0;
while (--argc > 0 && (*++argv)[0] == '-')
while (c = *++argv[0])
switch (c) {
case 'x':
except = 1;
break;
case 'n':
number = 1;
break;
default:
printf("find: illegal option %c\n", c);
argc = 0;
found = -1;
break;
}
if (argc != 1)
printf("Usage: find -x -n pattern\n");
else
while (getline(line, MAXLINE) > 0) {
lineno++;
if ((strstr(line, *argv) != NULL) != except) {
if (number)
printf("%ld:", lineno);
printf("%s", line);
found++;
}
}
return found;
}
argc is decremented and argv is incremented before each optional argument. At the end of the
loop, if there are no errors, argc tells how many arguments remain unprocessed and argv
points to the first of these. Thus argc should be 1 and *argv should point at the pattern.
Notice that *++argv is a pointer to an argument string, so (*++argv)[0] is its first character.
(An alternate valid form would be **++argv .) Because [] binds tighter than * and ++ , the
parentheses are necessary; without them the expression would be taken as *++(argv[0]) . In98
fact, that is what we have used in the inner loop, where the task is to walk along a specific
argument string. In the inner loop, the expression *++argv[0] increments the pointer
argv[0] !
It is rare that one uses pointer expressions more complicated than these; in such cases,
breaking them into two or three steps will be more intuitive.
Exercise 5-10. Write the program expr , which evaluates a reverse Polish expression from the
command line, where each operator or operand is a separate argument. For example,
expr 2 3 4 + *
evaluates 2 * (3+4).
Exercise 5-11. Modify the program entab and detab (written as exercises in Chapter 1) to
accept a list of tab stops as arguments. Use the default tab settings if there are no arguments.
Exercise 5-12. Extend entab and detab to accept the shorthand
entab -m +n
to mean tab stops every n columns, starting at column m. Choose convenient (for the user)
default behavior.
Exercise 5-13. Write the program tail , which prints the last n lines of its input. By default, n
is set to 10, let us say, but it can be changed by an optional argument so that
tail -n
prints the last n lines. The program should behave rationally no matter how unreasonable the
input or the value of n. Write the program so it makes the best use of available storage; lines
should be stored as in the sorting program of Section 5.6, not in a two-dimensional array of
fixed size.
5.11 Pointers to Functions
In C, a function itself is not a variable, but it is possible to define pointers to functions, which
can be assigned, placed in arrays, passed to functions, returned by functions, and so on. We
will illustrate this by modifying the sorting procedure written earlier in this chapter so that if
the optional argument -n is given, it will sort the input lines numerically instead of
lexicographically.
A sort often consists of three parts - a comparison that determines the ordering of any pair of
objects, an exchange that reverses their order, and a sorting algorithm that makes comparisons
and exchanges until the objects are in order. The sorting algorithm is independent of the
comparison and exchange operations, so by passing different comparison and exchange
functions to it, we can arrange to sort by different criteria. This is the approach taken in our
new sort.
Lexicographic comparison of two lines is done by strcmp , as before; we will also need a
routine numcmp that compares two lines on the basis of numeric value and returns the same
kind of condition indication as strcmp does. These functions are declared ahead of main and a
pointer to the appropriate one is passed to qsort . We have skimped on error processing for
arguments, so as to concentrate on the main issues.
#include <stdio.h>
#include <string.h>
#define MAXLINES 5000
char *lineptr[MAXLINES];
/* max #lines to be sorted */
/* pointers to text lines */99
int readlines(char *lineptr[], int nlines);
void writelines(char *lineptr[], int nlines);
void qsort(void *lineptr[], int left, int right,
int (*comp)(void *, void *));
int numcmp(char *, char *);
/* sort input lines */
main(int argc, char *argv[])
{
int nlines;
/* number of input lines read */
int numeric = 0;
/* 1 if numeric sort */
if (argc > 1 && strcmp(argv[1], "-n") == 0)
numeric = 1;
if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {
qsort((void**) lineptr, 0, nlines-1,
(int (*)(void*,void*))(numeric ? numcmp : strcmp));
writelines(lineptr, nlines);
return 0;
} else {
printf("input too big to sort\n");
return 1;
}
}
In the call to qsort , strcmp and numcmp are addresses of functions. Since they are known to
be functions, the & is not necessary, in the same way that it is not needed before an array name.
We have written qsort so it can process any data type, not just character strings. As indicated
by the function prototype, qsort expects an array of pointers, two integers, and a function
with two pointer arguments. The generic pointer type void * is used for the pointer
arguments. Any pointer can be cast to void * and back again without loss of information, so
we can call qsort by casting arguments to void * . The elaborate cast of the function
argument casts the arguments of the comparison function. These will generally have no effect
on actual representation, but assure the compiler that all is well.
sfsdSince any individual element of v (alias lineptr ) is a character pointer, temp must be also, so
sfsdSince any individual element of v (alias lineptr ) is a character pointer, temp must be also, so
sfsdSince any individual element of v (alias lineptr ) is a character pointer, temp must be also, so
one can be copied to the other.
Exercise 5-7. Rewrite readlines to store lines in an array supplied by main , rather than
calling alloc to maintain storage. How much faster is the program?
5.7 Multi-dimensional Arrays
C provides rectangular multi-dimensional arrays, although in practice they are much less used
than arrays of pointers. In this section, we will show some of their properties.
Consider the problem of date conversion, from day of the month to day of the year and vice
versa. For example, March 1 is the 60th day of a non-leap year, and the 61st day of a leap year.
Let us define two functions to do the conversions: day_of_year converts the month and day
into the day of the year, and month_day converts the day of the year into the month and day.
Since this latter function computes two values, the month and day arguments will be pointers:
month_day(1988, 60, &m, &d)
sets m to 2 and d to 29 (February 29th).
These functions both need the same information, a table of the number of days in each month
(``thirty days hath September ...''). Since the number of days per month differs for leap years
and non-leap years, it's easier to separate them into two rows of a two-dimensional array than
to keep track of what happens to February during computation. The array and the functions for
static char daytab[2][13] = {
{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
{0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};
/* day_of_year: set day of year from month & day */
int day_of_year(int year, int month, int day)
{
int i, leap;
leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
for (i = 1; i < month; i++)
day += daytab[leap][i];
return day;
}
/* month_day: set month, day from day of year */
void month_day(int year, int yearday, int *pmonth, int *pday)
{
int i, leap;93
leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
for (i = 1; yearday > daytab[leap][i]; i++)
yearday -= daytab[leap][i];
*pmonth = i;
*pday = yearday;
}
Recall that the arithmetic value of a logical expression, such as the one for leap , is either zero
(false) or one (true), so it can be used as a subscript of the array daytab .
The array daytab has to be external to both day_of_year and month_day , so they can both
use it. We made it char to illustrate a legitimate use of char for storing small non-character
integers.
daytab is the first two-dimensional array we have dealt with. In C, a two-dimensional array is
really a one-dimensional array, each of whose elements is an array. Hence subscripts are
written as
daytab[i][j]
/* [row][col] */
rather than
daytab[i,j]
/* WRONG */
Other than this notational distinction, a two-dimensional array can be treated in much the same
way as in other languages. Elements are stored by rows, so the rightmost subscript, or column,
varies fastest as elements are accessed in storage order.
An array is initialized by a list of initializers in braces; each row of a two-dimensional array is
initialized by a corresponding sub-list. We started the array daytab with a column of zero so
that month numbers can run from the natural 1 to 12 instead of 0 to 11. Since space is not at a
premium here, this is clearer than adjusting the indices.
If a two-dimensional array is to be passed to a function, the parameter declaration in the
function must include the number of columns; the number of rows is irrelevant, since what is
passed is, as before, a pointer to an array of rows, where each row is an array of 13 int s. In
this particular case, it is a pointer to objects that are arrays of 13 int s. Thus if the array
daytab is to be passed to a function f , the declaration of f would be:
f(int daytab[2][13]) { ... }
It could also be
f(int daytab[][13]) { ... }
since the number of rows is irrelevant, or it could be
f(int (*daytab)[13]) { ... }
which says that the parameter is a pointer to an array of 13 integers. The parentheses are
necessary since brackets [] have higher precedence than * . Without parentheses, the
declaration
int *daytab[13]
is an array of 13 pointers to integers. More generally, only the first dimension (subscript) of an
array is free; all the others have to be specified.
Section 5.12 has a further discussion of complicated declarations.
Exercise 5-8. There is no error checking in day_of_year or month_day . Remedy this defect.
5.8 Initialization of Pointer Arraysperforming the transformations are as follows:
since the number of rows is irrelevant, or it could be
f(int (*daytab)[13]) { ... }
which says that the parameter is a pointer to an array of 13 integers. The parentheses are
necessary since brackets [] have higher precedence than * . Without parentheses, the
declaration
int *daytab[13]
is an array of 13 pointers to integers. More generally, only the first dimension (subscript) of an
array is free; all the others have to be specified.
Section 5.12 has a further discussion of complicated declarations.
Exercise 5-8. There is no error checking in day_of_year or month_day . Remedy this defect.
5.8 Initialization of Pointer Arrays94
Consider the problem of writing a function month_name(n) , which returns a pointer to a
character string containing the name of the n -th month. This is an ideal application for an
internal static array. month_name contains a private array of character strings, and returns a
pointer to the proper one when called. This section shows how that array of names is
initialized.
The syntax is similar to previous initializations:
/* month_name: return name of n-th month */
char *month_name(int n)
{
static char *name[] = {
"Illegal month",
"January", "February", "March",
"April", "May", "June",
"July", "August", "September",
"October", "November", "December"
};
return (n < 1 || n > 12) ? name[0] : name[n];
}
The declaration of name , which is an array of character pointers, is the same as lineptr in the
sorting example. The initializer is a list of character strings; each is assigned to the
corresponding position in the array. The characters of the i -th string are placed somewhere,
and a pointer to them is stored in name[i] . Since the size of the array name is not specified,
the compiler counts the initializers and fills in the correct number.
5.9 Pointers vs. Multi-dimensional Arrays
Newcomers to C are sometimes confused about the difference between a two-dimensional
array and an array of pointers, such as name in the example above. Given the definitions
int a[10][20];
int *b[10];
then a[3][4] and b[3][4] are both syntactically legal references to a single int . But a is a
true two-dimensional array: 200 int -sized locations have been set aside, and the conventional
rectangular subscript calculation 20 * row +col is used to find the element a[row,col] . For b ,
however, the definition only allocates 10 pointers and does not initialize them; initialization
must be done explicitly, either statically or with code. Assuming that each element of b does
point to a twenty-element array, then there will be 200 int s set aside, plus ten cells for the
pointers. The important advantage of the pointer array is that the rows of the array may be of
different lengths. That is, each element of b need not point to a twenty-element vector; some
may point to two elements, some to fifty, and some to none at all.
Although we have phrased this discussion in terms of integers, by far the most frequent use of
arrays of pointers is to store character strings of diverse lengths, as in the function
month_name . Compare the declaration and picture for an array of pointers:
char *name[] = { "Illegal month", "Jan", "Feb", "Mar" };95
with those for a two-dimensional array:
char aname[][15] = { "Illegal month", "Jan", "Feb", "Mar" };
Exercise 5-9. Rewrite the routines day_of_year and month_day with pointers instead of
indexing.
5.10 Command-line Arguments
In environments that support C, there is a way to pass command-line arguments or parameters
to a program when it begins executing. When main is called, it is called with two arguments.
The first (conventionally called argc , for argument count) is the number of command-line
arguments the program was invoked with; the second ( argv , for argument vector) is a pointer
to an array of character strings that contain the arguments, one per string. We customarily use
multiple levels of pointers to manipulate these character strings.
The simplest illustration is the program echo , which echoes its command-line arguments on a
single line, separated by blanks. That is, the command
echo hello, world
prints the output
hello, world
By convention, argv[0] is the name by which the program was invoked, so argc is at least 1.
If argc is 1, there are no command-line arguments after the program name. In the example
above, argc is 3, and argv[0] , argv[1] , and argv[2] are "echo" , "hello," , and "world"
respectively. The first optional argument is argv[1] and the last is argv[argc-1] ;
additionally, the standard requires that argv[argc] be a null pointer.
The first version of echo treats argv as an array of character pointers:
#include <stdio.h>
/* echo command-line arguments; 1st version */
main(int argc, char *argv[])
{
int i;
for (i = 1; i < argc; i++)
printf("%s%s", argv[i], (i < argc-1) ? " " : "");
printf("\n");
return 0;96
}
Since argv is a pointer to an array of pointers, we can manipulate the pointer rather than index
the array. This next variant is based on incrementing argv , which is a pointer to pointer to
char , while argc is counted down:
#include <stdio.h>
/* echo command-line arguments; 2nd version */
main(int argc, char *argv[])
{
while (--argc > 0)
printf("%s%s", *++argv, (argc > 1) ? " " : "");
printf("\n");
return 0;
}
Since argv is a pointer to the beginning of the array of argument strings, incrementing it by 1
( ++argv ) makes it point at the original argv[1] instead of argv[0] . Each successive
increment moves it along to the next argument; *argv is then the pointer to that argument. At
the same time, argc is decremented; when it becomes zero, there are no arguments left to
print.
Alternatively, we could write the printf statement as
printf((argc > 1) ? "%s " : "%s", *++argv);
This shows that the format argument of printf can be an expression too.
As a second example, let us make some enhancements to the pattern-finding program from
Section 4.1. If you recall, we wired the search pattern deep into the program, an obviously
unsatisfactory arrangement. Following the lead of the UNIX program grep , let us enhance the
program so the pattern to be matched is specified by the first argument on the command line.
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000
int getline(char *line, int max);
/* find: print lines that match pattern from 1st arg */
main(int argc, char *argv[])
{
char line[MAXLINE];
int found = 0;
if (argc != 2)
printf("Usage: find pattern\n");
else
while (getline(line, MAXLINE) > 0)
if (strstr(line, argv[1]) != NULL) {
printf("%s", line);
found++;
}
return found;
}
The standard library function strstr(s,t) returns a pointer to the first occurrence of the
string t in the string s , or NULL if there is none. It is declared in <string.h> .
The model can now be elaborated to illustrate further pointer constructions. Suppose we want
to allow two optional arguments. One says ``print all the lines except those that match the
pattern;'' the second says ``precede each printed line by its line number.''97
A common convention for C programs on UNIX systems is that an argument that begins with
a minus sign introduces an optional flag or parameter. If we choose -x (for ``except'') to signal
the inversion, and -n (``number'') to request line numbering, then the command
find -x -npattern
will print each line that doesn't match the pattern, preceded by its line number.
Optional arguments should be permitted in any order, and the rest of the program should be
independent of the number of arguments that we present. Furthermore, it is convenient for
users if option arguments can be combined, as in
find -nx pattern
Here is the program:
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000
int getline(char *line, int max);
/* find: print lines that match pattern from 1st arg */
main(int argc, char *argv[])
{
char line[MAXLINE];
long lineno = 0;
int c, except = 0, number = 0, found = 0;
while (--argc > 0 && (*++argv)[0] == '-')
while (c = *++argv[0])
switch (c) {
case 'x':
except = 1;
break;
case 'n':
number = 1;
break;
default:
printf("find: illegal option %c\n", c);
argc = 0;
found = -1;
break;
}
if (argc != 1)
printf("Usage: find -x -n pattern\n");
else
while (getline(line, MAXLINE) > 0) {
lineno++;
if ((strstr(line, *argv) != NULL) != except) {
if (number)
printf("%ld:", lineno);
printf("%s", line);
found++;
}
}
return found;
}
argc is decremented and argv is incremented before each optional argument. At the end of the
loop, if there are no errors, argc tells how many arguments remain unprocessed and argv
points to the first of these. Thus argc should be 1 and *argv should point at the pattern.
Notice that *++argv is a pointer to an argument string, so (*++argv)[0] is its first character.
(An alternate valid form would be **++argv .) Because [] binds tighter than * and ++ , the
parentheses are necessary; without them the expression would be taken as *++(argv[0]) . In98
fact, that is what we have used in the inner loop, where the task is to walk along a specific
argument string. In the inner loop, the expression *++argv[0] increments the pointer
argv[0] !
It is rare that one uses pointer expressions more complicated than these; in such cases,
breaking them into two or three steps will be more intuitive.
Exercise 5-10. Write the program expr , which evaluates a reverse Polish expression from the
command line, where each operator or operand is a separate argument. For example,
expr 2 3 4 + *
evaluates 2 * (3+4).
Exercise 5-11. Modify the program entab and detab (written as exercises in Chapter 1) to
accept a list of tab stops as arguments. Use the default tab settings if there are no arguments.
Exercise 5-12. Extend entab and detab to accept the shorthand
entab -m +n
to mean tab stops every n columns, starting at column m. Choose convenient (for the user)
default behavior.
Exercise 5-13. Write the program tail , which prints the last n lines of its input. By default, n
is set to 10, let us say, but it can be changed by an optional argument so that
tail -n
prints the last n lines. The program should behave rationally no matter how unreasonable the
input or the value of n. Write the program so it makes the best use of available storage; lines
should be stored as in the sorting program of Section 5.6, not in a two-dimensional array of
fixed size.
5.11 Pointers to Functions
In C, a function itself is not a variable, but it is possible to define pointers to functions, which
can be assigned, placed in arrays, passed to functions, returned by functions, and so on. We
will illustrate this by modifying the sorting procedure written earlier in this chapter so that if
the optional argument -n is given, it will sort the input lines numerically instead of
lexicographically.
A sort often consists of three parts - a comparison that determines the ordering of any pair of
objects, an exchange that reverses their order, and a sorting algorithm that makes comparisons
and exchanges until the objects are in order. The sorting algorithm is independent of the
comparison and exchange operations, so by passing different comparison and exchange
functions to it, we can arrange to sort by different criteria. This is the approach taken in our
new sort.
Lexicographic comparison of two lines is done by strcmp , as before; we will also need a
routine numcmp that compares two lines on the basis of numeric value and returns the same
kind of condition indication as strcmp does. These functions are declared ahead of main and a
pointer to the appropriate one is passed to qsort . We have skimped on error processing for
arguments, so as to concentrate on the main issues.
#include <stdio.h>
#include <string.h>
#define MAXLINES 5000
char *lineptr[MAXLINES];
/* max #lines to be sorted */
/* pointers to text lines */99
int readlines(char *lineptr[], int nlines);
void writelines(char *lineptr[], int nlines);
void qsort(void *lineptr[], int left, int right,
int (*comp)(void *, void *));
int numcmp(char *, char *);
/* sort input lines */
main(int argc, char *argv[])
{
int nlines;
/* number of input lines read */
int numeric = 0;
/* 1 if numeric sort */
if (argc > 1 && strcmp(argv[1], "-n") == 0)
numeric = 1;
if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {
qsort((void**) lineptr, 0, nlines-1,
(int (*)(void*,void*))(numeric ? numcmp : strcmp));
writelines(lineptr, nlines);
return 0;
} else {
printf("input too big to sort\n");
return 1;
}
}
In the call to qsort , strcmp and numcmp are addresses of functions. Since they are known to
be functions, the & is not necessary, in the same way that it is not needed before an array name.
We have written qsort so it can process any data type, not just character strings. As indicated
by the function prototype, qsort expects an array of pointers, two integers, and a function
with two pointer arguments. The generic pointer type void * is used for the pointer
arguments. Any pointer can be cast to void * and back again without loss of information, so
we can call qsort by casting arguments to void * . The elaborate cast of the function
argument casts the arguments of the comparison function. These will generally have no effect
on actual representation, but assure the compiler that all is well.
one can be copied to the other.
Exercise 5-7. Rewrite readlines to store lines in an array supplied by main , rather than
calling alloc to maintain storage. How much faster is the program?
5.7 Multi-dimensional Arrays
C provides rectangular multi-dimensional arrays, although in practice they are much less used
than arrays of pointers. In this section, we will show some of their properties.
Consider the problem of date conversion, from day of the month to day of the year and vice
versa. For example, March 1 is the 60th day of a non-leap year, and the 61st day of a leap year.
Let us define two functions to do the conversions: day_of_year converts the month and day
into the day of the year, and month_day converts the day of the year into the month and day.
Since this latter function computes two values, the month and day arguments will be pointers:
month_day(1988, 60, &m, &d)
sets m to 2 and d to 29 (February 29th).
These functions both need the same information, a table of the number of days in each month
(``thirty days hath September ...''). Since the number of days per month differs for leap years
and non-leap years, it's easier to separate them into two rows of a two-dimensional array than
to keep track of what happens to February during computation. The array and the functions for
static char daytab[2][13] = {
{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
{0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};
/* day_of_year: set day of year from month & day */
int day_of_year(int year, int month, int day)
{
int i, leap;
leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
for (i = 1; i < month; i++)
day += daytab[leap][i];
return day;
}
/* month_day: set month, day from day of year */
void month_day(int year, int yearday, int *pmonth, int *pday)
{
int i, leap;93
leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
for (i = 1; yearday > daytab[leap][i]; i++)
yearday -= daytab[leap][i];
*pmonth = i;
*pday = yearday;
}
Recall that the arithmetic value of a logical expression, such as the one for leap , is either zero
(false) or one (true), so it can be used as a subscript of the array daytab .
The array daytab has to be external to both day_of_year and month_day , so they can both
use it. We made it char to illustrate a legitimate use of char for storing small non-character
integers.
daytab is the first two-dimensional array we have dealt with. In C, a two-dimensional array is
really a one-dimensional array, each of whose elements is an array. Hence subscripts are
written as
daytab[i][j]
/* [row][col] */
rather than
daytab[i,j]
/* WRONG */
Other than this notational distinction, a two-dimensional array can be treated in much the same
way as in other languages. Elements are stored by rows, so the rightmost subscript, or column,
varies fastest as elements are accessed in storage order.
An array is initialized by a list of initializers in braces; each row of a two-dimensional array is
initialized by a corresponding sub-list. We started the array daytab with a column of zero so
that month numbers can run from the natural 1 to 12 instead of 0 to 11. Since space is not at a
premium here, this is clearer than adjusting the indices.
If a two-dimensional array is to be passed to a function, the parameter declaration in the
function must include the number of columns; the number of rows is irrelevant, since what is
passed is, as before, a pointer to an array of rows, where each row is an array of 13 int s. In
this particular case, it is a pointer to objects that are arrays of 13 int s. Thus if the array
daytab is to be passed to a function f , the declaration of f would be:
f(int daytab[2][13]) { ... }
It could also be
f(int daytab[][13]) { ... }
since the number of rows is irrelevant, or it could be
f(int (*daytab)[13]) { ... }
which says that the parameter is a pointer to an array of 13 integers. The parentheses are
necessary since brackets [] have higher precedence than * . Without parentheses, the
declaration
int *daytab[13]
is an array of 13 pointers to integers. More generally, only the first dimension (subscript) of an
array is free; all the others have to be specified.
Section 5.12 has a further discussion of complicated declarations.
Exercise 5-8. There is no error checking in day_of_year or month_day . Remedy this defect.
5.8 Initialization of Pointer Arraysperforming the transformations are as follows:
since the number of rows is irrelevant, or it could be
f(int (*daytab)[13]) { ... }
which says that the parameter is a pointer to an array of 13 integers. The parentheses are
necessary since brackets [] have higher precedence than * . Without parentheses, the
declaration
int *daytab[13]
is an array of 13 pointers to integers. More generally, only the first dimension (subscript) of an
array is free; all the others have to be specified.
Section 5.12 has a further discussion of complicated declarations.
Exercise 5-8. There is no error checking in day_of_year or month_day . Remedy this defect.
5.8 Initialization of Pointer Arrays94
Consider the problem of writing a function month_name(n) , which returns a pointer to a
character string containing the name of the n -th month. This is an ideal application for an
internal static array. month_name contains a private array of character strings, and returns a
pointer to the proper one when called. This section shows how that array of names is
initialized.
The syntax is similar to previous initializations:
/* month_name: return name of n-th month */
char *month_name(int n)
{
static char *name[] = {
"Illegal month",
"January", "February", "March",
"April", "May", "June",
"July", "August", "September",
"October", "November", "December"
};
return (n < 1 || n > 12) ? name[0] : name[n];
}
The declaration of name , which is an array of character pointers, is the same as lineptr in the
sorting example. The initializer is a list of character strings; each is assigned to the
corresponding position in the array. The characters of the i -th string are placed somewhere,
and a pointer to them is stored in name[i] . Since the size of the array name is not specified,
the compiler counts the initializers and fills in the correct number.
5.9 Pointers vs. Multi-dimensional Arrays
Newcomers to C are sometimes confused about the difference between a two-dimensional
array and an array of pointers, such as name in the example above. Given the definitions
int a[10][20];
int *b[10];
then a[3][4] and b[3][4] are both syntactically legal references to a single int . But a is a
true two-dimensional array: 200 int -sized locations have been set aside, and the conventional
rectangular subscript calculation 20 * row +col is used to find the element a[row,col] . For b ,
however, the definition only allocates 10 pointers and does not initialize them; initialization
must be done explicitly, either statically or with code. Assuming that each element of b does
point to a twenty-element array, then there will be 200 int s set aside, plus ten cells for the
pointers. The important advantage of the pointer array is that the rows of the array may be of
different lengths. That is, each element of b need not point to a twenty-element vector; some
may point to two elements, some to fifty, and some to none at all.
Although we have phrased this discussion in terms of integers, by far the most frequent use of
arrays of pointers is to store character strings of diverse lengths, as in the function
month_name . Compare the declaration and picture for an array of pointers:
char *name[] = { "Illegal month", "Jan", "Feb", "Mar" };95
with those for a two-dimensional array:
char aname[][15] = { "Illegal month", "Jan", "Feb", "Mar" };
Exercise 5-9. Rewrite the routines day_of_year and month_day with pointers instead of
indexing.
5.10 Command-line Arguments
In environments that support C, there is a way to pass command-line arguments or parameters
to a program when it begins executing. When main is called, it is called with two arguments.
The first (conventionally called argc , for argument count) is the number of command-line
arguments the program was invoked with; the second ( argv , for argument vector) is a pointer
to an array of character strings that contain the arguments, one per string. We customarily use
multiple levels of pointers to manipulate these character strings.
The simplest illustration is the program echo , which echoes its command-line arguments on a
single line, separated by blanks. That is, the command
echo hello, world
prints the output
hello, world
By convention, argv[0] is the name by which the program was invoked, so argc is at least 1.
If argc is 1, there are no command-line arguments after the program name. In the example
above, argc is 3, and argv[0] , argv[1] , and argv[2] are "echo" , "hello," , and "world"
respectively. The first optional argument is argv[1] and the last is argv[argc-1] ;
additionally, the standard requires that argv[argc] be a null pointer.
The first version of echo treats argv as an array of character pointers:
#include <stdio.h>
/* echo command-line arguments; 1st version */
main(int argc, char *argv[])
{
int i;
for (i = 1; i < argc; i++)
printf("%s%s", argv[i], (i < argc-1) ? " " : "");
printf("\n");
return 0;96
}
Since argv is a pointer to an array of pointers, we can manipulate the pointer rather than index
the array. This next variant is based on incrementing argv , which is a pointer to pointer to
char , while argc is counted down:
#include <stdio.h>
/* echo command-line arguments; 2nd version */
main(int argc, char *argv[])
{
while (--argc > 0)
printf("%s%s", *++argv, (argc > 1) ? " " : "");
printf("\n");
return 0;
}
Since argv is a pointer to the beginning of the array of argument strings, incrementing it by 1
( ++argv ) makes it point at the original argv[1] instead of argv[0] . Each successive
increment moves it along to the next argument; *argv is then the pointer to that argument. At
the same time, argc is decremented; when it becomes zero, there are no arguments left to
print.
Alternatively, we could write the printf statement as
printf((argc > 1) ? "%s " : "%s", *++argv);
This shows that the format argument of printf can be an expression too.
As a second example, let us make some enhancements to the pattern-finding program from
Section 4.1. If you recall, we wired the search pattern deep into the program, an obviously
unsatisfactory arrangement. Following the lead of the UNIX program grep , let us enhance the
program so the pattern to be matched is specified by the first argument on the command line.
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000
int getline(char *line, int max);
/* find: print lines that match pattern from 1st arg */
main(int argc, char *argv[])
{
char line[MAXLINE];
int found = 0;
if (argc != 2)
printf("Usage: find pattern\n");
else
while (getline(line, MAXLINE) > 0)
if (strstr(line, argv[1]) != NULL) {
printf("%s", line);
found++;
}
return found;
}
The standard library function strstr(s,t) returns a pointer to the first occurrence of the
string t in the string s , or NULL if there is none. It is declared in <string.h> .
The model can now be elaborated to illustrate further pointer constructions. Suppose we want
to allow two optional arguments. One says ``print all the lines except those that match the
pattern;'' the second says ``precede each printed line by its line number.''97
A common convention for C programs on UNIX systems is that an argument that begins with
a minus sign introduces an optional flag or parameter. If we choose -x (for ``except'') to signal
the inversion, and -n (``number'') to request line numbering, then the command
find -x -npattern
will print each line that doesn't match the pattern, preceded by its line number.
Optional arguments should be permitted in any order, and the rest of the program should be
independent of the number of arguments that we present. Furthermore, it is convenient for
users if option arguments can be combined, as in
find -nx pattern
Here is the program:
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000
int getline(char *line, int max);
/* find: print lines that match pattern from 1st arg */
main(int argc, char *argv[])
{
char line[MAXLINE];
long lineno = 0;
int c, except = 0, number = 0, found = 0;
while (--argc > 0 && (*++argv)[0] == '-')
while (c = *++argv[0])
switch (c) {
case 'x':
except = 1;
break;
case 'n':
number = 1;
break;
default:
printf("find: illegal option %c\n", c);
argc = 0;
found = -1;
break;
}
if (argc != 1)
printf("Usage: find -x -n pattern\n");
else
while (getline(line, MAXLINE) > 0) {
lineno++;
if ((strstr(line, *argv) != NULL) != except) {
if (number)
printf("%ld:", lineno);
printf("%s", line);
found++;
}
}
return found;
}
argc is decremented and argv is incremented before each optional argument. At the end of the
loop, if there are no errors, argc tells how many arguments remain unprocessed and argv
points to the first of these. Thus argc should be 1 and *argv should point at the pattern.
Notice that *++argv is a pointer to an argument string, so (*++argv)[0] is its first character.
(An alternate valid form would be **++argv .) Because [] binds tighter than * and ++ , the
parentheses are necessary; without them the expression would be taken as *++(argv[0]) . In98
fact, that is what we have used in the inner loop, where the task is to walk along a specific
argument string. In the inner loop, the expression *++argv[0] increments the pointer
argv[0] !
It is rare that one uses pointer expressions more complicated than these; in such cases,
breaking them into two or three steps will be more intuitive.
Exercise 5-10. Write the program expr , which evaluates a reverse Polish expression from the
command line, where each operator or operand is a separate argument. For example,
expr 2 3 4 + *
evaluates 2 * (3+4).
Exercise 5-11. Modify the program entab and detab (written as exercises in Chapter 1) to
accept a list of tab stops as arguments. Use the default tab settings if there are no arguments.
Exercise 5-12. Extend entab and detab to accept the shorthand
entab -m +n
to mean tab stops every n columns, starting at column m. Choose convenient (for the user)
default behavior.
Exercise 5-13. Write the program tail , which prints the last n lines of its input. By default, n
is set to 10, let us say, but it can be changed by an optional argument so that
tail -n
prints the last n lines. The program should behave rationally no matter how unreasonable the
input or the value of n. Write the program so it makes the best use of available storage; lines
should be stored as in the sorting program of Section 5.6, not in a two-dimensional array of
fixed size.
5.11 Pointers to Functions
In C, a function itself is not a variable, but it is possible to define pointers to functions, which
can be assigned, placed in arrays, passed to functions, returned by functions, and so on. We
will illustrate this by modifying the sorting procedure written earlier in this chapter so that if
the optional argument -n is given, it will sort the input lines numerically instead of
lexicographically.
A sort often consists of three parts - a comparison that determines the ordering of any pair of
objects, an exchange that reverses their order, and a sorting algorithm that makes comparisons
and exchanges until the objects are in order. The sorting algorithm is independent of the
comparison and exchange operations, so by passing different comparison and exchange
functions to it, we can arrange to sort by different criteria. This is the approach taken in our
new sort.
Lexicographic comparison of two lines is done by strcmp , as before; we will also need a
routine numcmp that compares two lines on the basis of numeric value and returns the same
kind of condition indication as strcmp does. These functions are declared ahead of main and a
pointer to the appropriate one is passed to qsort . We have skimped on error processing for
arguments, so as to concentrate on the main issues.
#include <stdio.h>
#include <string.h>
#define MAXLINES 5000
char *lineptr[MAXLINES];
/* max #lines to be sorted */
/* pointers to text lines */99
int readlines(char *lineptr[], int nlines);
void writelines(char *lineptr[], int nlines);
void qsort(void *lineptr[], int left, int right,
int (*comp)(void *, void *));
int numcmp(char *, char *);
/* sort input lines */
main(int argc, char *argv[])
{
int nlines;
/* number of input lines read */
int numeric = 0;
/* 1 if numeric sort */
if (argc > 1 && strcmp(argv[1], "-n") == 0)
numeric = 1;
if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {
qsort((void**) lineptr, 0, nlines-1,
(int (*)(void*,void*))(numeric ? numcmp : strcmp));
writelines(lineptr, nlines);
return 0;
} else {
printf("input too big to sort\n");
return 1;
}
}
In the call to qsort , strcmp and numcmp are addresses of functions. Since they are known to
be functions, the & is not necessary, in the same way that it is not needed before an array name.
We have written qsort so it can process any data type, not just character strings. As indicated
by the function prototype, qsort expects an array of pointers, two integers, and a function
with two pointer arguments. The generic pointer type void * is used for the pointer
arguments. Any pointer can be cast to void * and back again without loss of information, so
we can call qsort by casting arguments to void * . The elaborate cast of the function
argument casts the arguments of the comparison function. These will generally have no effect
on actual representation, but assure the compiler that all is well.
one can be copied to the other.
Exercise 5-7. Rewrite readlines to store lines in an array supplied by main , rather than
calling alloc to maintain storage. How much faster is the program?
5.7 Multi-dimensional Arrays
C provides rectangular multi-dimensional arrays, although in practice they are much less used
than arrays of pointers. In this section, we will show some of their properties.
Consider the problem of date conversion, from day of the month to day of the year and vice
versa. For example, March 1 is the 60th day of a non-leap year, and the 61st day of a leap year.
Let us define two functions to do the conversions: day_of_year converts the month and day
into the day of the year, and month_day converts the day of the year into the month and day.
Since this latter function computes two values, the month and day arguments will be pointers:
month_day(1988, 60, &m, &d)
sets m to 2 and d to 29 (February 29th).
These functions both need the same information, a table of the number of days in each month
(``thirty days hath September ...''). Since the number of days per month differs for leap years
and non-leap years, it's easier to separate them into two rows of a two-dimensional array than
to keep track of what happens to February during computation. The array and the functions for
static char daytab[2][13] = {
{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
{0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};
/* day_of_year: set day of year from month & day */
int day_of_year(int year, int month, int day)
{
int i, leap;
leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
for (i = 1; i < month; i++)
day += daytab[leap][i];
return day;
}
/* month_day: set month, day from day of year */
void month_day(int year, int yearday, int *pmonth, int *pday)
{
int i, leap;93
leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
for (i = 1; yearday > daytab[leap][i]; i++)
yearday -= daytab[leap][i];
*pmonth = i;
*pday = yearday;
}
Recall that the arithmetic value of a logical expression, such as the one for leap , is either zero
(false) or one (true), so it can be used as a subscript of the array daytab .
The array daytab has to be external to both day_of_year and month_day , so they can both
use it. We made it char to illustrate a legitimate use of char for storing small non-character
integers.
daytab is the first two-dimensional array we have dealt with. In C, a two-dimensional array is
really a one-dimensional array, each of whose elements is an array. Hence subscripts are
written as
daytab[i][j]
/* [row][col] */
rather than
daytab[i,j]
/* WRONG */
Other than this notational distinction, a two-dimensional array can be treated in much the same
way as in other languages. Elements are stored by rows, so the rightmost subscript, or column,
varies fastest as elements are accessed in storage order.
An array is initialized by a list of initializers in braces; each row of a two-dimensional array is
initialized by a corresponding sub-list. We started the array daytab with a column of zero so
that month numbers can run from the natural 1 to 12 instead of 0 to 11. Since space is not at a
premium here, this is clearer than adjusting the indices.
If a two-dimensional array is to be passed to a function, the parameter declaration in the
function must include the number of columns; the number of rows is irrelevant, since what is
passed is, as before, a pointer to an array of rows, where each row is an array of 13 int s. In
this particular case, it is a pointer to objects that are arrays of 13 int s. Thus if the array
daytab is to be passed to a function f , the declaration of f would be:
f(int daytab[2][13]) { ... }
It could also be
f(int daytab[][13]) { ... }
since the number of rows is irrelevant, or it could be
f(int (*daytab)[13]) { ... }
which says that the parameter is a pointer to an array of 13 integers. The parentheses are
necessary since brackets [] have higher precedence than * . Without parentheses, the
declaration
int *daytab[13]
is an array of 13 pointers to integers. More generally, only the first dimension (subscript) of an
array is free; all the others have to be specified.
Section 5.12 has a further discussion of complicated declarations.
Exercise 5-8. There is no error checking in day_of_year or month_day . Remedy this defect.
5.8 Initialization of Pointer Arraysperforming the transformations are as follows:
since the number of rows is irrelevant, or it could be
f(int (*daytab)[13]) { ... }
which says that the parameter is a pointer to an array of 13 integers. The parentheses are
necessary since brackets [] have higher precedence than * . Without parentheses, the
declaration
int *daytab[13]
is an array of 13 pointers to integers. More generally, only the first dimension (subscript) of an
array is free; all the others have to be specified.
Section 5.12 has a further discussion of complicated declarations.
Exercise 5-8. There is no error checking in day_of_year or month_day . Remedy this defect.
5.8 Initialization of Pointer Arrays94
Consider the problem of writing a function month_name(n) , which returns a pointer to a
character string containing the name of the n -th month. This is an ideal application for an
internal static array. month_name contains a private array of character strings, and returns a
pointer to the proper one when called. This section shows how that array of names is
initialized.
The syntax is similar to previous initializations:
/* month_name: return name of n-th month */
char *month_name(int n)
{
static char *name[] = {
"Illegal month",
"January", "February", "March",
"April", "May", "June",
"July", "August", "September",
"October", "November", "December"
};
return (n < 1 || n > 12) ? name[0] : name[n];
}
The declaration of name , which is an array of character pointers, is the same as lineptr in the
sorting example. The initializer is a list of character strings; each is assigned to the
corresponding position in the array. The characters of the i -th string are placed somewhere,
and a pointer to them is stored in name[i] . Since the size of the array name is not specified,
the compiler counts the initializers and fills in the correct number.
5.9 Pointers vs. Multi-dimensional Arrays
Newcomers to C are sometimes confused about the difference between a two-dimensional
array and an array of pointers, such as name in the example above. Given the definitions
int a[10][20];
int *b[10];
then a[3][4] and b[3][4] are both syntactically legal references to a single int . But a is a
true two-dimensional array: 200 int -sized locations have been set aside, and the conventional
rectangular subscript calculation 20 * row +col is used to find the element a[row,col] . For b ,
however, the definition only allocates 10 pointers and does not initialize them; initialization
must be done explicitly, either statically or with code. Assuming that each element of b does
point to a twenty-element array, then there will be 200 int s set aside, plus ten cells for the
pointers. The important advantage of the pointer array is that the rows of the array may be of
different lengths. That is, each element of b need not point to a twenty-element vector; some
may point to two elements, some to fifty, and some to none at all.
Although we have phrased this discussion in terms of integers, by far the most frequent use of
arrays of pointers is to store character strings of diverse lengths, as in the function
month_name . Compare the declaration and picture for an array of pointers:
char *name[] = { "Illegal month", "Jan", "Feb", "Mar" };95
with those for a two-dimensional array:
char aname[][15] = { "Illegal month", "Jan", "Feb", "Mar" };
Exercise 5-9. Rewrite the routines day_of_year and month_day with pointers instead of
indexing.
5.10 Command-line Arguments
In environments that support C, there is a way to pass command-line arguments or parameters
to a program when it begins executing. When main is called, it is called with two arguments.
The first (conventionally called argc , for argument count) is the number of command-line
arguments the program was invoked with; the second ( argv , for argument vector) is a pointer
to an array of character strings that contain the arguments, one per string. We customarily use
multiple levels of pointers to manipulate these character strings.
The simplest illustration is the program echo , which echoes its command-line arguments on a
single line, separated by blanks. That is, the command
echo hello, world
prints the output
hello, world
By convention, argv[0] is the name by which the program was invoked, so argc is at least 1.
If argc is 1, there are no command-line arguments after the program name. In the example
above, argc is 3, and argv[0] , argv[1] , and argv[2] are "echo" , "hello," , and "world"
respectively. The first optional argument is argv[1] and the last is argv[argc-1] ;
additionally, the standard requires that argv[argc] be a null pointer.
The first version of echo treats argv as an array of character pointers:
#include <stdio.h>
/* echo command-line arguments; 1st version */
main(int argc, char *argv[])
{
int i;
for (i = 1; i < argc; i++)
printf("%s%s", argv[i], (i < argc-1) ? " " : "");
printf("\n");
return 0;96
}
Since argv is a pointer to an array of pointers, we can manipulate the pointer rather than index
the array. This next variant is based on incrementing argv , which is a pointer to pointer to
char , while argc is counted down:
#include <stdio.h>
/* echo command-line arguments; 2nd version */
main(int argc, char *argv[])
{
while (--argc > 0)
printf("%s%s", *++argv, (argc > 1) ? " " : "");
printf("\n");
return 0;
}
Since argv is a pointer to the beginning of the array of argument strings, incrementing it by 1
( ++argv ) makes it point at the original argv[1] instead of argv[0] . Each successive
increment moves it along to the next argument; *argv is then the pointer to that argument. At
the same time, argc is decremented; when it becomes zero, there are no arguments left to
print.
Alternatively, we could write the printf statement as
printf((argc > 1) ? "%s " : "%s", *++argv);
This shows that the format argument of printf can be an expression too.
As a second example, let us make some enhancements to the pattern-finding program from
Section 4.1. If you recall, we wired the search pattern deep into the program, an obviously
unsatisfactory arrangement. Following the lead of the UNIX program grep , let us enhance the
program so the pattern to be matched is specified by the first argument on the command line.
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000
int getline(char *line, int max);
/* find: print lines that match pattern from 1st arg */
main(int argc, char *argv[])
{
char line[MAXLINE];
int found = 0;
if (argc != 2)
printf("Usage: find pattern\n");
else
while (getline(line, MAXLINE) > 0)
if (strstr(line, argv[1]) != NULL) {
printf("%s", line);
found++;
}
return found;
}
The standard library function strstr(s,t) returns a pointer to the first occurrence of the
string t in the string s , or NULL if there is none. It is declared in <string.h> .
The model can now be elaborated to illustrate further pointer constructions. Suppose we want
to allow two optional arguments. One says ``print all the lines except those that match the
pattern;'' the second says ``precede each printed line by its line number.''97
A common convention for C programs on UNIX systems is that an argument that begins with
a minus sign introduces an optional flag or parameter. If we choose -x (for ``except'') to signal
the inversion, and -n (``number'') to request line numbering, then the command
find -x -npattern
will print each line that doesn't match the pattern, preceded by its line number.
Optional arguments should be permitted in any order, and the rest of the program should be
independent of the number of arguments that we present. Furthermore, it is convenient for
users if option arguments can be combined, as in
find -nx pattern
Here is the program:
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000
int getline(char *line, int max);
/* find: print lines that match pattern from 1st arg */
main(int argc, char *argv[])
{
char line[MAXLINE];
long lineno = 0;
int c, except = 0, number = 0, found = 0;
while (--argc > 0 && (*++argv)[0] == '-')
while (c = *++argv[0])
switch (c) {
case 'x':
except = 1;
break;
case 'n':
number = 1;
break;
default:
printf("find: illegal option %c\n", c);
argc = 0;
found = -1;
break;
}
if (argc != 1)
printf("Usage: find -x -n pattern\n");
else
while (getline(line, MAXLINE) > 0) {
lineno++;
if ((strstr(line, *argv) != NULL) != except) {
if (number)
printf("%ld:", lineno);
printf("%s", line);
found++;
}
}
return found;
}
argc is decremented and argv is incremented before each optional argument. At the end of the
loop, if there are no errors, argc tells how many arguments remain unprocessed and argv
points to the first of these. Thus argc should be 1 and *argv should point at the pattern.
Notice that *++argv is a pointer to an argument string, so (*++argv)[0] is its first character.
(An alternate valid form would be **++argv .) Because [] binds tighter than * and ++ , the
parentheses are necessary; without them the expression would be taken as *++(argv[0]) . In98
fact, that is what we have used in the inner loop, where the task is to walk along a specific
argument string. In the inner loop, the expression *++argv[0] increments the pointer
argv[0] !
It is rare that one uses pointer expressions more complicated than these; in such cases,
breaking them into two or three steps will be more intuitive.
Exercise 5-10. Write the program expr , which evaluates a reverse Polish expression from the
command line, where each operator or operand is a separate argument. For example,
expr 2 3 4 + *
evaluates 2 * (3+4).
Exercise 5-11. Modify the program entab and detab (written as exercises in Chapter 1) to
accept a list of tab stops as arguments. Use the default tab settings if there are no arguments.
Exercise 5-12. Extend entab and detab to accept the shorthand
entab -m +n
to mean tab stops every n columns, starting at column m. Choose convenient (for the user)
default behavior.
Exercise 5-13. Write the program tail , which prints the last n lines of its input. By default, n
is set to 10, let us say, but it can be changed by an optional argument so that
tail -n
prints the last n lines. The program should behave rationally no matter how unreasonable the
input or the value of n. Write the program so it makes the best use of available storage; lines
should be stored as in the sorting program of Section 5.6, not in a two-dimensional array of
fixed size.
5.11 Pointers to Functions
In C, a function itself is not a variable, but it is possible to define pointers to functions, which
can be assigned, placed in arrays, passed to functions, returned by functions, and so on. We
will illustrate this by modifying the sorting procedure written earlier in this chapter so that if
the optional argument -n is given, it will sort the input lines numerically instead of
lexicographically.
A sort often consists of three parts - a comparison that determines the ordering of any pair of
objects, an exchange that reverses their order, and a sorting algorithm that makes comparisons
and exchanges until the objects are in order. The sorting algorithm is independent of the
comparison and exchange operations, so by passing different comparison and exchange
functions to it, we can arrange to sort by different criteria. This is the approach taken in our
new sort.
Lexicographic comparison of two lines is done by strcmp , as before; we will also need a
routine numcmp that compares two lines on the basis of numeric value and returns the same
kind of condition indication as strcmp does. These functions are declared ahead of main and a
pointer to the appropriate one is passed to qsort . We have skimped on error processing for
arguments, so as to concentrate on the main issues.
#include <stdio.h>
#include <string.h>
#define MAXLINES 5000
char *lineptr[MAXLINES];
/* max #lines to be sorted */
/* pointers to text lines */99
int readlines(char *lineptr[], int nlines);
void writelines(char *lineptr[], int nlines);
void qsort(void *lineptr[], int left, int right,
int (*comp)(void *, void *));
int numcmp(char *, char *);
/* sort input lines */
main(int argc, char *argv[])
{
int nlines;
/* number of input lines read */
int numeric = 0;
/* 1 if numeric sort */
if (argc > 1 && strcmp(argv[1], "-n") == 0)
numeric = 1;
if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {
qsort((void**) lineptr, 0, nlines-1,
(int (*)(void*,void*))(numeric ? numcmp : strcmp));
writelines(lineptr, nlines);
return 0;
} else {
printf("input too big to sort\n");
return 1;
}
}
In the call to qsort , strcmp and numcmp are addresses of functions. Since they are known to
be functions, the & is not necessary, in the same way that it is not needed before an array name.
We have written qsort so it can process any data type, not just character strings. As indicated
by the function prototype, qsort expects an array of pointers, two integers, and a function
with two pointer arguments. The generic pointer type void * is used for the pointer
arguments. Any pointer can be cast to void * and back again without loss of information, so
we can call qsort by casting arguments to void * . The elaborate cast of the function
argument casts the arguments of the comparison function. These will generally have no effect
/* qsort: sort v[left]...v[right] into increasing order */
void qsort(void *v[], int left, int right,
int (*comp)(void *, void *))
{
int i, last;
void swap(void *v[], int, int);
if (left >= right)
/* do nothing if array contains */
return;
/* fewer than two elements */
swap(v, left, (left + right)/2);
last = left;
for (i = left+1; i <= right; i++)
if ((*comp)(v[i], v[left]) < 0)
swap(v, ++last, i);
swap(v, left, last);
qsort(v, left, last-1, comp);
qsort(v, last+1, right, comp);
}
The declarations should be studied with some care. The fourth parameter of qsort is
int (*comp)(void *, void *)
which says that comp is a pointer to a function that has two void * arguments and returns an
int .
The use of comp in the line
if ((*comp)(v[i], v[left]) < 0)100
is consistent with the declaration: comp is a pointer to a function, *comp is the function, and
(*comp)(v[i], v[left])
is the call to it. The parentheses are needed so the components are correctly associated;
without them,
int *comp(void *, void *)
/* WRONG */
says that comp is a function returning a pointer to an int , which is very different.
We have already shown strcmp , which compares two strings. Here is numcmp , which
compares two strings on a leading numeric value, computed by calling atof :
#include <stdlib.h>
/* numcmp: compare s1 and s2 numerically */
int numcmp(char *s1, char *s2)
{
double v1, v2;
v1 = atof(s1);
v2 = atof(s2);
if (v1 < v2)
return -1;
else if (v1 > v2)
return 1;
else
return 0;
}
The swap function, which exchanges two pointers, is identical to what we presented earlier in
the chapter, except that the declarations are changed to void * .
void swap(void *v[],
{
void *temp;
int i, int j;)
temp = v[i];
v[i] = v[j];
v[j] = temp;
}
A variety of other options can be added to the sorting program; some make challenging
exercises.
Exercise 5-14. Modify the sort program to handle a -r flag, which indicates sorting in reverse
(decreasing) order. Be sure that -r works with -n .
Exercise 5-15. Add the option -f to fold upper and lower case together, so that case
distinctions are not made during sorting; for example, a and A compare equal.
Exercise 5-16. Add the -d (``directory order'') option, which makes comparisons only on
letters, numbers and blanks. Make sure it works in conjunction with -f .
Exercise 5-17. Add a field-searching capability, so sorting may bee done on fields within lines,
each field sorted according to an independent set of options. (The index for this book was
sorted with -df for the index category and -n for the page numbers.)
5.12 Complicated Declarations
C is sometimes castigated for the syntax of its declarations, particularly ones that involve
pointers to functions. The syntax is an attempt to make the declaration and the use agree; it
works well for simple cases, but it can be confusing for the harder ones, because declarations
cannot be read left to right, and because parentheses are over-used. The difference between101
int *f(); /* f: function returning pointer to int */
int (*pf)(); /* pf: pointer to function returning int */
and
illustrates the problem: * is a prefix operator and it has lower precedence than () , so
parentheses are necessary to force the proper association.
Although truly complicated declarations rarely arise in practice, it is important to know how to
understand them, and, if necessary, how to create them. One good way to synthesize
declarations is in small steps with typedef , which is discussed in Section 6.7. As an
alternative, in this section we will present a pair of programs that convert from valid C to a
word description and back again. The word description reads left to right.
The first, dcl , is the more complex. It converts a C declaration into a word description, as in
these examples:
char **argv
argv: pointer to char
int (*daytab)[13]
daytab: pointer to array[13] of int
int *daytab[13]
daytab: array[13] of pointer to int
void *comp()
comp: function returning pointer to void
void (*comp)()
comp: pointer to function returning void
char (*(*x())[])()
x: function returning pointer to array[] of
pointer to function returning char
char (*(*x[3])())[5]
x: array[3] of pointer to function returning
pointer to array[5] of char
dcl is based on the grammar that specifies a declarator, which is spelled out precisely in
Appendix A, Section 8.5; this is a simplified form:
dcl:
optional *'s direct-dcl
direct-dcl name
(dcl)
direct-dcl()
direct-dcl[optional size]
In words, a dcl is a direct-dcl, perhaps preceded by *'s. A direct-dcl is a name, or a
parenthesized dcl, or a direct-dcl followed by parentheses, or a direct-dcl followed by brackets
with an optional size.
This grammar can be used to parse functions. For instance, consider this declarator:
(*pfa[])()
pfa will be identified as a name and thus as a direct-dcl. Then pfa[] is also a direct-dcl. Then
*pfa[] is recognized as a dcl, so (*pfa[]) is a direct-dcl. Then (*pfa[])() is a direct-dcl
and thus a dcl. We can also illustrate the parse with a tree like this (where direct-dcl has been
abbreviated to dir-dcl):102
The heart of the dcl program is a pair of functions, dcl and dirdcl , that parse a declaration
according to this grammar. Because the grammar is recursively defined, the functions call each
other recursively as they recognize pieces of a declaration; the program is called a recursive-
descent parser.
/* dcl: parse a declarator */
void dcl(void)
{
int ns;
for (ns = 0; gettoken() == '*'; ) /* count *'s */
ns++;
dirdcl();
while (ns-- > 0)
strcat(out, " pointer to");
}
/* dirdcl: parse a direct declarator */
void dirdcl(void)
{
int type;
if (tokentype == '(') {
/* ( dcl ) */
dcl();
if (tokentype != ')')
printf("error: missing )\n");
} else if (tokentype == NAME) /* variable name */
strcpy(name, token);
else
printf("error: expected name or (dcl)\n");
while ((type=gettoken()) == PARENS || type == BRACKETS)103
if (type == PARENS)
strcat(out, " function returning");
else {
strcat(out, " array");
strcat(out, token);
strcat(out, " of");
}
}
Since the programs are intended to be illustrative, not bullet-proof, there are significant
restrictions on dcl . It can only handle a simple data type line char or int . It does not handle
argument types in functions, or qualifiers like const . Spurious blanks confuse it. It doesn't do
much error recovery, so invalid declarations will also confuse it. These improvements are left
as exercises.
Here are the global variables and the main routine:
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#define MAXTOKEN
100
enum { NAME, PARENS, BRACKETS };
void dcl(void);
void dirdcl(void);
int gettoken(void);
int tokentype;
char token[MAXTOKEN];
char name[MAXTOKEN];
char datatype[MAXTOKEN];
char out[1000];
/*
/*
/*
/*
type of last token */
last token string */
identifier name */
data type = char, int, etc. */
main() /* convert declaration to words */
{
while (gettoken() != EOF) {
/* 1st token on line */
strcpy(datatype, token); /* is the datatype */
out[0] = '\0';
dcl();
/* parse rest of line */
if (tokentype != '\n')
printf("syntax error\n");
printf("%s: %s %s\n", name, out, datatype);
}
return 0;
}
The function gettoken skips blanks and tabs, then finds the next token in the input; a ``token''
is a name, a pair of parentheses, a pair of brackets perhaps including a number, or any other
single character.
int gettoken(void) /* return next token */
{
int c, getch(void);
void ungetch(int);
char *p = token;
while ((c = getch()) == ' ' || c == '\t')
;
if (c == '(') {
if ((c = getch()) == ')') {
strcpy(token, "()");
return tokentype = PARENS;
} else {
ungetch(c);
return tokentype = '(';104
}
} else if (c == '[') {
for (*p++ = c; (*p++ = getch()) != ']'; )
;
*p = '\0';
return tokentype = BRACKETS;
} else if (isalpha(c)) {
for (*p++ = c; isalnum(c = getch()); )
*p++ = c;
*p = '\0';
ungetch(c);
return tokentype = NAME;
} else
return tokentype = c;
}
getch and ungetch are discussed in Chapter 4.
Going in the other direction is easier, especially if we do not worry about generating redundant
parentheses. The program undcl converts a word description like `` x is a function returning a
pointer to an array of pointers to functions returning char ,'' which we will express as
x () * [] * () char
to
char (*(*x())[])()
The abbreviated input syntax lets us reuse the gettoken function. undcl also uses the same
external variables as dcl does.
/* undcl: convert word descriptions to declarations */
main()
{
int type;
char temp[MAXTOKEN];
while (gettoken() != EOF) {
strcpy(out, token);
while ((type = gettoken()) != '\n')
if (type == PARENS || type == BRACKETS)
strcat(out, token);
else if (type == '*') {
sprintf(temp, "(*%s)", out);
strcpy(out, temp);
} else if (type == NAME) {
sprintf(temp, "%s %s", token, out);
strcpy(out, temp);
} else
printf("invalid input at %s\n", token);
}
return 0;
}
Exercise 5-18. Make dcl recover from input errors.
Exercise 5-19. Modify undcl so that it does not add redundant parentheses to declarations.
Exercise 5-20. Expand dcl to handle declarations with function argument types, qualifiers like
const , and so on.105
Chapter 6 - Structures
A structure is a collection of one or more variables, possibly of different types, grouped
together under a single name for convenient handling. (Structures are called ``records'' in some
languages, notably Pascal.) Structures help to organize complicated data, particularly in large
programs, because they permit a group of related variables to be treated as a unit instead of as
separate entities.
One traditional example of a structure is the payroll record: an employee is described by a set
of attributes such as name, address, social security number, salary, etc. Some of these in turn
could be structures: a name has several components, as does an address and even a salary.
Another example, more typical for C, comes from graphics: a point is a pair of coordinate, a
rectangle is a pair of points, and so on.
The main change made by the ANSI standard is to define structure assignment - structures may
be copied and assigned to, passed to functions, and returned by functions. This has been
supported by most compilers for many years, but the properties are now precisely defined.
Automatic structures and arrays may now also be initialized.
6.1 Basics of Structures
Let us create a few structures suitable for graphics. The basic object is a point, which we will
assume has an x coordinate and a y coordinate, both integers.
The two components can be placed in a structure declared like this:
struct point {
int x;
int y;
};
The keyword struct introduces a structure declaration, which is a list of declarations enclosed
in braces. An optional name called a structure tag may follow the word struct (as with point
here). The tag names this kind of structure, and can be used subsequently as a shorthand for
the part of the declaration in braces.
The variables named in a structure are called members. A structure member or tag and an
ordinary (i.e., non-member) variable can have the same name without conflict, since they can
always be distinguished by context. Furthermore, the same member names may occur in
different structures, although as a matter of style one would normally use the same names only
for closely related objects.
A struct declaration defines a type. The right brace that terminates the list of members may
be followed by a list of variables, just as for any basic type. That is,106
struct { ... } x, y, z;
is syntactically analogous to
int x, y, z;
in the sense that each statement declares x , y and z to be variables of the named type and
causes space to be set aside for them.
A structure declaration that is not followed by a list of variables reserves no storage; it merely
describes a template or shape of a structure. If the declaration is tagged, however, the tag can
be used later in definitions of instances of the structure. For example, given the declaration of
point above,
struct point pt;
defines a variable pt which is a structure of type struct point . A structure can be initialized
by following its definition with a list of initializers, each a constant expression, for the
members:
struct maxpt = { 320, 200 };
An automatic structure may also be initialized by assignment or by calling a function that
returns a structure of the right type.
A member of a particular structure is referred to in an expression by a construction of the form
structure-name.member
The structure member operator ``.'' connects the structure name and the member name. To
print the coordinates of the point pt , for instance,
printf("%d,%d", pt.x, pt.y);
or to compute the distance from the origin (0,0) to pt ,
double dist, sqrt(double);
dist = sqrt((double)pt.x * pt.x + (double)pt.y * pt.y);
Structures can be nested. One representation of a rectangle is a pair of points that denote the
diagonally opposite corners:
struct rect {
struct point pt1;
struct point pt2;
};
The rect structure contains two point structures. If we declare screen as
struct rect screen;
then
screen.pt1.x107
refers to the x coordinate of the pt1 member of screen .
6.2 Structures and Functions
The only legal operations on a structure are copying it or assigning to it as a unit, taking its
address with & , and accessing its members. Copy and assignment include passing arguments to
functions and returning values from functions as well. Structures may not be compared. A
structure may be initialized by a list of constant member values; an automatic structure may
also be initialized by an assignment.
Let us investigate structures by writing some functions to manipulate points and rectangles.
There are at least three possible approaches: pass components separately, pass an entire
structure, or pass a pointer to it. Each has its good points and bad points.
The first function, makepoint , will take two integers and return a point structure:
/* makepoint: make a point from x and y components */
struct point makepoint(int x, int y)
{
struct point temp;
temp.x = x;
temp.y = y;
return temp;
}
Notice that there is no conflict between the argument name and the member with the same
name; indeed the re-use of the names stresses the relationship.
makepoint can now be used to initialize any structure dynamically, or to provide structure
arguments to a function:
struct rect screen;
struct point middle;
struct point makepoint(int, int);
screen.pt1 = makepoint(0,0);
screen.pt2 = makepoint(XMAX, YMAX);
middle = makepoint((screen.pt1.x + screen.pt2.x)/2,
(screen.pt1.y + screen.pt2.y)/2);
The next step is a set of functions to do arithmetic on points. For instance,
/* addpoints: add two points */
struct addpoint(struct point p1, struct point p2)
{
p1.x += p2.x;
p1.y += p2.y;
return p1;
}
Here both the arguments and the return value are structures. We incremented the components
in p1 rather than using an explicit temporary variable to emphasize that structure parameters
are passed by value like any others.
As another example, the function ptinrect tests whether a point is inside a rectangle, where
we have adopted the convention that a rectangle includes its left and bottom sides but not its
top and right sides:
/* ptinrect: return 1 if
int ptinrect(struct point
{
return p.x >= r.pt1.x
&& p.y >= r.pt1.y
}
p in r, 0 if not */
p, struct rect r)
&& p.x < r.pt2.x
&& p.y < r.pt2.y;108
This assumes that the rectangle is presented in a standard form where the pt1 coordinates are
less than the pt2 coordinates. The following function returns a rectangle guaranteed to be in
canonical form:
#define min(a, b) ((a) < (b) ? (a) : (b))
#define max(a, b) ((a) > (b) ? (a) : (b))
/* canonrect: canonicalize coordinates of rectangle */
struct rect canonrect(struct rect r)
{
struct rect temp;
temp.pt1.x =
temp.pt1.y =
temp.pt2.x =
temp.pt2.y =
return temp;
min(r.pt1.x,
min(r.pt1.y,
max(r.pt1.x,
max(r.pt1.y,
r.pt2.x);
r.pt2.y);
r.pt2.x);
r.pt2.y);
}
If a large structure is to be passed to a function, it is generally more efficient to pass a pointer
than to copy the whole structure. Structure pointers are just like pointers to ordinary variables.
The declaration
struct point *pp;
says that pp is a pointer to a structure of type struct point . If pp points to a point
structure, *pp is the structure, and (*pp).x and (*pp).y are the members. To use pp , we
might write, for example,
struct point origin, *pp;
pp = &origin;
printf("origin is (%d,%d)\n", (*pp).x, (*pp).y);
The parentheses are necessary in (*pp).x because the precedence of the structure member
operator . is higher then * . The expression *pp.x means *(pp.x) , which is illegal here
because x is not a pointer.
Pointers to structures are so frequently used that an alternative notation is provided as a
shorthand. If p is a pointer to a structure, then
p->member-of-structure
refers to the particular member. So we could write instead
printf("origin is (%d,%d)\n", pp->x, pp->y);
Both . and -> associate from left to right, so if we have
struct rect r, *rp = &r;
then these four expressions are equivalent:
r.pt1.x
rp->pt1.x
(r.pt1).x
(rp->pt1).x
The structure operators . and -> , together with () for function calls and [] for subscripts, are
at the top of the precedence hierarchy and thus bind very tightly. For example, given the
declaration
struct {
int len;
char *str;
} *p;
then109
++p->len
increments len , not p , because the implied parenthesization is ++(p->len) . Parentheses can be
used to alter binding: (++p)->len increments p before accessing len , and (p++)->len
increments p afterward. (This last set of parentheses is unnecessary.)
In the same way, *p->str fetches whatever str points to; *p->str++ increments str after
accessing whatever it points to (just like *s++ ); (*p->str)++ increments whatever str points
to; and *p++->str increments p after accessing whatever str points to.
6.3 Arrays of Structures
Consider writing a program to count the occurrences of each C keyword. We need an array of
character strings to hold the names, and an array of integers for the counts. One possibility is
to use two parallel arrays, keyword and keycount , as in
char *keyword[NKEYS];
int keycount[NKEYS];
But the very fact that the arrays are parallel suggests a different organization, an array of
structures. Each keyword is a pair:
char *word;
int cout;
and there is an array of pairs. The structure declaration
struct key {
char *word;
int count;
} keytab[NKEYS];
declares a structure type key , defines an array keytab of structures of this type, and sets aside
storage for them. Each element of the array is a structure. This could also be written
struct key {
char *word;
int count;
};
struct key keytab[NKEYS];
Since the structure keytab contains a constant set of names, it is easiest to make it an external
variable and initialize it once and for all when it is defined. The structure initialization is
analogous to earlier ones - the definition is followed by a list of initializers enclosed in braces:
struct key {
char *word;
int count;
} keytab[] = {
"auto", 0,
"break", 0,
"case", 0,
"char", 0,
"const", 0,
"continue", 0,
"default", 0,
/* ... */
"unsigned", 0,
"void", 0,
"volatile", 0,
"while", 0
};
The initializers are listed in pairs corresponding to the structure members. It would be more
precise to enclose the initializers for each "row" or structure in braces, as in
{ "auto", 0 },110
{ "break", 0 },
{ "case", 0 },
...
but inner braces are not necessary when the initializers are simple variables or character strings,
and when all are present. As usual, the number of entries in the array keytab will be computed
if the initializers are present and the [] is left empty.
The keyword counting program begins with the definition of keytab . The main routine reads
the input by repeatedly calling a function getword that fetches one word at a time. Each word
is looked up in keytab with a version of the binary search function that we wrote in Chapter 3.
The list of keywords must be sorted in increasing order in the table.
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#define MAXWORD 100
int getword(char *, int);
int binsearch(char *, struct key *, int);
/* count C keywords */
main()
{
int n;
char word[MAXWORD];
while (getword(word, MAXWORD) != EOF)
if (isalpha(word[0]))
if ((n = binsearch(word, keytab, NKEYS)) >= 0)
keytab[n].count++;
for (n = 0; n < NKEYS; n++)
if (keytab[n].count > 0)
printf("%4d %s\n",
keytab[n].count, keytab[n].word);
return 0;
}
/* binsearch: find word in tab[0]...tab[n-1] */
int binsearch(char *word, struct key tab[], int n)
{
int cond;
int low, high, mid;
low = 0;
high = n - 1;
while (low <= high) {
mid = (low+high) / 2;
if ((cond = strcmp(word, tab[mid].word)) < 0)
high = mid - 1;
else if (cond > 0)
low = mid + 1;
else
return mid;
}
return -1;
}
We will show the function getword in a moment; for now it suffices to say that each call to
getword finds a word, which is copied into the array named as its first argument.
The quantity NKEYS is the number of keywords in keytab . Although we could count this by
hand, it's a lot easier and safer to do it by machine, especially if the list is subject to change.
One possibility would be to terminate the list of initializers with a null pointer, then loop along
keytab until the end is found.111
But this is more than is needed, since the size of the array is completely determined at compile
time. The size of the array is the size of one entry times the number of entries, so the number
of entries is just
size of keytab / size of struct key
C provides a compile-time unary operator called sizeof that can be used to compute the size
of any object. The expressions
sizeof object
and
sizeof (type name)
yield an integer equal to the size of the specified object or type in bytes. (Strictly, sizeof
produces an unsigned integer value whose type, size_t , is defined in the header <stddef.h> .)
An object can be a variable or array or structure. A type name can be the name of a basic type
like int or double , or a derived type like a structure or a pointer.
In our case, the number of keywords is the size of the array divided by the size of one element.
This computation is used in a #define statement to set the value of NKEYS :
#define NKEYS (sizeof keytab / sizeof(struct key))
Another way to write this is to divide the array size by the size of a specific element:
#define NKEYS (sizeof keytab / sizeof(keytab[0]))
This has the advantage that it does not need to be changed if the type changes.
A sizeof can not be used in a #if line, because the preprocessor does not parse type names.
But the expression in the #define is not evaluated by the preprocessor, so the code here is
legal.
Now for the function getword . We have written a more general getword than is necessary for
this program, but it is not complicated. getword fetches the next ``word'' from the input,
where a word is either a string of letters and digits beginning with a letter, or a single non-
white space character. The function value is the first character of the word, or EOF for end of
file, or the character itself if it is not alphabetic.
/* getword: get next word or character from input */
int getword(char *word, int lim)
{
int c, getch(void);
void ungetch(int);
char *w = word;
while (isspace(c = getch()))
;
if (c != EOF)
*w++ = c;
if (!isalpha(c)) {
*w = '\0';
return c;
}
for ( ; --lim > 0; w++)
if (!isalnum(*w = getch())) {
ungetch(*w);
break;
}
*w = '\0';
return word[0];
}112
getword uses the getch and ungetch that we wrote in Chapter 4. When the collection of an
alphanumeric token stops, getword has gone one character too far. The call to ungetch
pushes that character back on the input for the next call. getword also uses isspace to skip
whitespace, isalpha to identify letters, and isalnum to identify letters and digits; all are from
the standard header <ctype.h> .
Exercise 6-1. Our version of getword does not properly handle underscores, string constants,
comments, or preprocessor control lines. Write a better version.
6.4 Pointers to Structures
To illustrate some of the considerations involved with pointers to and arrays of structures, let
us write the keyword-counting program again, this time using pointers instead of array indices.
The external declaration of keytab need not change, but main and binsearch do need
modification.
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#define MAXWORD 100
int getword(char *, int);
struct key *binsearch(char *, struct key *, int);
/* count C keywords; pointer version */
main()
{
char word[MAXWORD];
struct key *p;
while (getword(word, MAXWORD) != EOF)
if (isalpha(word[0]))
if ((p=binsearch(word, keytab, NKEYS)) != NULL)
p->count++;
for (p = keytab; p < keytab + NKEYS; p++)
if (p->count > 0)
printf("%4d %s\n", p->count, p->word);
return 0;
}
/* binsearch: find word in tab[0]...tab[n-1] */
struct key *binsearch(char *word, struck key *tab, int n)
{
int cond;
struct key *low = &tab[0];
struct key *high = &tab[n];
struct key *mid;
while (low < high) {
mid = low + (high-low) / 2;
if ((cond = strcmp(word, mid->word)) < 0)
high = mid;
else if (cond > 0)
low = mid + 1;
else
return mid;
}
return NULL;
}
There are several things worthy of note here. First, the declaration of binsearch must indicate
that it returns a pointer to struct key instead of an integer; this is declared both in the113
function prototype and in binsearch . If binsearch finds the word, it returns a pointer to it; if
it fails, it returns NULL .
Second, the elements of keytab are now accessed by pointers. This requires significant
changes in binsearch .
The initializers for low and high are now pointers to the beginning and just past the end of the
table.
The computation of the middle element can no longer be simply
mid = (low+high) / 2
/* WRONG */
because the addition of pointers is illegal. Subtraction is legal, however, so high-low is the
number of elements, and thus
mid = low + (high-low) / 2
sets mid to the element halfway between low and high .
The most important change is to adjust the algorithm to make sure that it does not generate an
illegal pointer or attempt to access an element outside the array. The problem is that &tab[-1]
and &tab[n] are both outside the limits of the array tab . The former is strictly illegal, and it is
illegal to dereference the latter. The language definition does guarantee, however, that pointer
arithmetic that involves the first element beyond the end of an array (that is, &tab[n] ) will
work correctly.
In main we wrote
for (p = keytab; p < keytab + NKEYS; p++)
If p is a pointer to a structure, arithmetic on p takes into account the size of the structure, so
p++ increments p by the correct amount to get the next element of the array of structures, and
the test stops the loop at the right time.
Don't assume, however, that the size of a structure is the sum of the sizes of its members.
Because of alignment requirements for different objects, there may be unnamed ``holes'' in a
structure. Thus, for instance, if a char is one byte and an int four bytes, the structure
struct {
char c;
int i;
};
might well require eight bytes, not five. The sizeof operator returns the proper value.
Finally, an aside on program format: when a function returns a complicated type like a
structure pointer, as in
struct key *binsearch(char *word, struct key *tab, int n)
the function name can be hard to see, and to find with a text editor. Accordingly an alternate
style is sometimes used:
struct key *
binsearch(char *word, struct key *tab, int n)
This is a matter of personal taste; pick the form you like and hold to it.
6.5 Self-referential Structures
Suppose we want to handle the more general problem of counting the occurrences of all the
wprog >outfile
will write the standard output to outfile instead. If pipes are supported,
prog | anotherprog
puts the standard output of prog into the standard input of anotherprog .
Output produced by printf also finds its way to the standard output. Calls to putchar and
printf may be interleaved - output happens in the order in which the calls are made.
Each source file that refers to an input/output library function must contain the line
#include <stdio.h>
before the first reference. When the name is bracketed by < and > a search is made for the
header in a standard set of places (for example, on UNIX systems, typically in the directory
/usr/include ).
Many programs read only one input stream and write only one output stream; for such
programs, input and output with getchar , putchar , and printf may be entirely adequate,
and is certainly enough to get started. This is particularly true if redirection is used to connect
the output of one program to the input of the next. For example, consider the program lower ,
which converts its input to lower case:
#include <stdio.h>
#include <ctype.h>
main() /* lower: convert input to lower case*/
{
int c
while ((c = getchar()) != EOF)
putchar(tolower(c));
return 0;
}
The function tolower is defined in <ctype.h> ; it converts an upper case letter to lower case,
and returns other characters untouched. As we mentioned earlier, ``functions'' like getchar
and putchar in <stdio.h> and tolower in <ctype.h> are often macros, thus avoiding the
overhead of a function call per character. We will show how this is done in Section 8.5.
Regardless of how the <ctype.h> functions are implemented on a given machine, programs
that use them are shielded from knowledge of the character set.
Exercise 7-1. Write a program that converts upper case to lower or lower case to upper,
depending on the name it is invoked with, as found in argv[0] .
7.2 Formatted Output - printf
The output function printf translates internal values to characters. We have used printf
informally in previous chapters. The description here covers most typical uses but is not
complete; for the full story, see Appendix B.
int printf(char *format, arg1, arg2, ...);
printf converts, formats, and prints its arguments on the standard output under control of the
format . It returns the number of characters printed.
The format string contains two types of objects: ordinary characters, which are copied to the
output stream, and conversion specifications, each of which causes conversion and printing of
the next successive argument to printf . Each conversion specification begins with a % and
ends with a conversion character. Between the % and the conversion character there may be,
in order:126
• A minus sign, which specifies left adjustment of the converted argument.
• A number that specifies the minimum field width. The converted argument will be
printed in a field at least this wide. If necessary it will be padded on the left (or right, if
left adjustment is called for) to make up the field width.
• A period, which separates the field width from the precision.
• A number, the precision, that specifies the maximum number of characters to be printed
from a string, or the number of digits after the decimal point of a floating-point value,
or the minimum number of digits for an integer.
• An h if the integer is to be printed as a short , or l (letter ell) if as a long .
Conversion characters are shown in Table 7.1. If the character after the % is not a conversion
specification, the behavior is undefined.
Table 7.1 Basic Printf Conversions
Character
Argument type; Printed As
d,i int ; decimal number
o int ; unsigned octal number (without a leading zero)
x,X int ; unsigned hexadecimal number (without a leading 0x or 0X ), using abcdef or
ABCDEF for 10, ...,15.
u int ; unsigned decimal number
c int ; single character
s char * ; print characters from the string until a '\0' or the number of characters
f
e,E
g,G
p
%
given by the precision.
double ; [-] m.dddddd, where the number of d's is given by the precision (default
6).
double ; [-] m.dddddd e+/- xx or [-] m.dddddd E+/- xx, where the number of d's
is given by the precision (default 6).
double ; use %e or %E if the exponent is less than -4 or greater than or equal to the
precision; otherwise use %f . Trailing zeros and a trailing decimal point are not
printed.
void * ; pointer (implementation-dependent representation).
no argument is converted; print a %
A width or precision may be specified as *, in which case the value is computed by converting
the next argument (which must be an int ). For example, to print at most max characters from
a string s ,
printf("%.*s", max, s);
Most of the format conversions have been illustrated in earlier chapters. One exception is the
precision as it relates to strings. The following table shows the effect of a variety of
specifications in printing ``hello, world'' (12 characters). We have put colons around each field
so you can see it extent.
:%s:
:%10s:
:%.10s:
:%-10s:
:%.15s:
:%-15s:
:%15.10s:
:%-15.10s:
:hello, world:
:hello, world:
:hello, wor:
:hello, world:
:hello, world:
:hello, world
:
:
hello, wor:
:hello, wor
:127
A warning: printf uses its first argument to decide how many arguments follow and what
their type is. It will get confused, and you will get wrong answers, if there are not enough
arguments of if they are the wrong type. You should also be aware of the difference between
these two calls:
printf(s);
/* FAILS if s contains % */
printf("%s", s);
/* SAFE */
The function sprintf does the same conversions as printf does, but stores the output in a
string:
int sprintf(char *string, char *format, arg1, arg2, ...);
sprintf formats the arguments in arg1 , arg2 , etc., according to format as before, but places
the result in string instead of the standard output; string must be big enough to receive the
result.
Exercise 7-2. Write a program that will print arbitrary input in a sensible way. As a minimum,
it should print non-graphic characters in octal or hexadecimal according to local custom, and
break long text lines.
7.3 Variable-length Argument Lists
This section contains an implementation of a minimal version of printf , to show how to write
a function that processes a variable-length argument list in a portable way. Since we are mainly
interested in the argument processing, minprintf will process the format string and arguments
but will call the real printf to do the format conversions.
The proper declaration for printf is
int printf(char *fmt, ...)
where the declaration ... means that the number and types of these arguments may vary. The
declaration ... can only appear at the end of an argument list. Our minprintf is declared as
void minprintf(char *fmt, ...)
since we will not return the character count that printf does.
The tricky bit is how minprintf walks along the argument list when the list doesn't even have
a name. The standard header <stdarg.h> contains a set of macro definitions that define how
to step through an argument list. The implementation of this header will vary from machine to
machine, but the interface it presents is uniform.
The type va_list is used to declare a variable that will refer to each argument in turn; in
minprintf , this variable is called ap , for ``argument pointer.'' The macro va_start initializes
ap to point to the first unnamed argument. It must be called once before ap is used. There
must be at least one named argument; the final named argument is used by va_start to get
started.
Each call of va_arg returns one argument and steps ap to the next; va_arg uses a type name
to determine what type to return and how big a step to take. Finally, va_end does whatever
cleanup is necessary. It must be called before the program returns.
These properties form the basis of our simplified printf :
#include <stdarg.h>
/* minprintf: minimal printf with variable argument list */
void minprintf(char *fmt, ...)
{
va_list ap; /* points to each unnamed arg in turn */
char *p, *sval;128
int ival;
double dval;
va_start(ap, fmt); /* make ap point to 1st unnamed arg */
for (p = fmt; *p; p++) {
if (*p != '%') {
putchar(*p);
continue;
}
switch (*++p) {
case 'd':
ival = va_arg(ap, int);
printf("%d", ival);
break;
case 'f':
dval = va_arg(ap, double);
printf("%f", dval);
break;
case 's':
for (sval = va_arg(ap, char *); *sval; sval++)
putchar(*sval);
break;
default:
putchar(*p);
break;
}
}
va_end(ap); /* clean up when done */
}
Exercise 7-3. Revise minprintf to handle more of the other facilities of printf .
7.4 Formatted Input - Scanf
The function scanf is the input analog of printf , providing many of the same conversion
facilities in the opposite direction.
int scanf(char *format, ...)
scanf reads characters from the standard input, interprets them according to the specification
in format , and stores the results through the remaining arguments. The format argument is
described below; the other arguments, each of which must be a pointer, indicate where the
corresponding converted input should be stored. As with printf , this section is a summary of
the most useful features, not an exhaustive list.
scanf stops when it exhausts its format string, or when some input fails to match the control
specification. It returns as its value the number of successfully matched and assigned input
items. This can be used to decide how many items were found. On the end of file, EOF is
returned; note that this is different from 0, which means that the next input character does not
match the first specification in the format string. The next call to scanf resumes searching
immediately after the last character already converted.
There is also a function sscanf that reads from a string instead of the standard input:
int sscanf(char *string, char *format, arg1, arg2, ...)
It scans the string according to the format in format and stores the resulting values through
arg1 , arg2 , etc. These arguments must be pointers.
The format string usually contains conversion specifications, which are used to control
conversion of input. The format string may contain:
•
Blanks or tabs, which are not ignored.129
• Ordinary characters (not %), which are expected to match the next non-white space
character of the input stream.
• Conversion specifications, consisting of the character % , an optional assignment
suppression character * , an optional number specifying a maximum field width, an
optional h , l or L indicating the width of the target, and a conversion character.
A conversion specification directs the conversion of the next input field. Normally the result is
places in the variable pointed to by the corresponding argument. If assignment suppression is
indicated by the * character, however, the input field is skipped; no assignment is made. An
input field is defined as a string of non-white space characters; it extends either to the next
white space character or until the field width, is specified, is exhausted. This implies that scanf
will read across boundaries to find its input, since newlines are white space. (White space
characters are blank, tab, newline, carriage return, vertical tab, and formfeed.)
The conversion character indicates the interpretation of the input field. The corresponding
argument must be a pointer, as required by the call-by-value semantics of C. Conversion
characters are shown in Table 7.2.
Table 7.2: Basic Scanf Conversions
Character
d
i
o
u
x
c
s
e,f,g
%
Input Data; Argument type
decimal integer; int *
integer; int * . The integer may be in octal (leading 0 ) or hexadecimal (leading
0x or 0X ).
octal integer (with or without leading zero); int *
unsigned decimal integer; unsigned int *
hexadecimal integer (with or without leading 0x or 0X ); int *
characters; char * . The next input characters (default 1) are placed at the
indicated spot. The normal skip-over white space is suppressed; to read the next
non-white space character, use %1s
character string (not quoted); char * , pointing to an array of characters long
enough for the string and a terminating '\0' that will be added.
floating-point number with optional sign, optional decimal point and optional
exponent; float *
literal %; no assignment is made.
The conversion characters d , i , o , u , and x may be preceded by h to indicate that a pointer to
short rather than int appears in the argument list, or by l (letter ell) to indicate that a pointer
to long appears in the argument list.
As a first example, the rudimentary calculator of Chapter 4 can be written with scanf to do
the input conversion:
#include <stdio.h>
main() /* rudimentary calculator */
{
double sum, v;
sum = 0;
while (scanf("%lf", &v) == 1)
printf("\t%.2f\n", sum += v);
return 0;
}
Suppose we want to read input lines that contain dates of the form130
25 Dec 1988
The scanf statement is
int day, year;
char monthname[20];
scanf("%d %s %d", &day, monthname, &year);
No & is used with monthname , since an array name is a pointer.
Literal characters can appear in the scanf format string; they must match the same characters
in the input. So we could read dates of the form mm/dd/yy with the scanf statement:
int day, month, year;
scanf("%d/%d/%d", &month, &day, &year);
scanf ignores blanks and tabs in its format string. Furthermore, it skips over white space
(blanks, tabs, newlines, etc.) as it looks for input values. To read input whose format is not
fixed, it is often best to read a line at a time, then pick it apart with scanf . For example,
suppose we want to read lines that might contain a date in either of the forms above. Then we
could write
while (getline(line, sizeof(line)) > 0) {
if (sscanf(line, "%d %s %d", &day, monthname, &year) == 3)
printf("valid: %s\n", line); /* 25 Dec 1988 form */
else if (sscanf(line, "%d/%d/%d", &month, &day, &year) == 3)
printf("valid: %s\n", line); /* mm/dd/yy form */
else
printf("invalid: %s\n", line); /* invalid form */
}
Calls to scanf can be mixed with calls to other input functions. The next call to any input
function will begin by reading the first character not read by scanf .
A final warning: the arguments to scanf and sscanf must be pointers. By far the most
common error is writing
scanf("%d", n);
instead of
scanf("%d", &n);
This error is not generally detected at compile time.
Exercise 7-4. Write a private version of scanf analogous to minprintf from the previous
section.
Exercise 5-5. Rewrite the postfix calculator of Chapter 4 to use scanf and/or sscanf to do
the input and number conversion.
7.5 File Access
The examples so far have all read the standard input and written the standard output, which are
automatically defined for a program by the local operating system.
The next step is to write a program that accesses a file that is not already connected to the
program. One program that illustrates the need for such operations is cat , which concatenates
a set of named files into the standard output. cat is used for printing files on the screen, and as
a general-purpose input collector for programs that do not have the capability of accessing files
by name. For example, the command
cat x.c y.c131
prints the contents of the files x.c and y.c (and nothing else) on the standard output.
The question is how to arrange for the named files to be read - that is, how to connect the
external names that a user thinks of to the statements that read the data.
The rules are simple. Before it can be read or written, a file has to be opened by the library
function fopen . fopen takes an external name like x.c or y.c , does some housekeeping and
negotiation with the operating system (details of which needn't concern us), and returns a
pointer to be used in subsequent reads or writes of the file.
This pointer, called the file pointer, points to a structure that contains information about the
file, such as the location of a buffer, the current character position in the buffer, whether the
file is being read or written, and whether errors or end of file have occurred. Users don't need
to know the details, because the definitions obtained from <stdio.h> include a structure
declaration called FILE . The only declaration needed for a file pointer is exemplified by
FILE *fp;
FILE *fopen(char *name, char *mode);
This says that fp is a pointer to a FILE , and fopen returns a pointer to a FILE . Notice that
FILE is a type name, like int , not a structure tag; it is defined with a typedef . (Details of how
fopen can be implemented on the UNIX system are given in Section 8.5.)
The call to fopen in a program is
fp = fopen(name, mode);
The first argument of fopen is a character string containing the name of the file. The second
argument is the mode, also a character string, which indicates how one intends to use the file.
Allowable modes include read ( "r" ), write ( "w" ), and append ( "a" ). Some systems distinguish
between text and binary files; for the latter, a "b" must be appended to the mode string.
If a file that does not exist is opened for writing or appending, it is created if possible. Opening
an existing file for writing causes the old contents to be discarded, while opening for appending
preserves them. Trying to read a file that does not exist is an error, and there may be other
causes of error as well, like trying to read a file when you don't have permission. If there is any
error, fopen will return NULL . (The error can be identified more precisely; see the discussion of
error-handling functions at the end of Section 1 in Appendix B.)
The next thing needed is a way to read or write the file once it is open. getc returns the next
character from a file; it needs the file pointer to tell it which file.
int getc(FILE *fp)
getc returns the next character from the stream referred to by fp ; it returns EOF for end of file
or error.
putc is an output function:
int putc(int c, FILE *fp)
putc writes the character c to the file fp and returns the character written, or EOF if an error
occurs. Like getchar and putchar , getc and putc may be macros instead of functions.
When a C program is started, the operating system environment is responsible for opening
three files and providing pointers for them. These files are the standard input, the standard
output, and the standard error; the corresponding file pointers are called stdin , stdout , and
stderr , and are declared in <stdio.h> . Normally stdin is connected to the keyboard and
stdout and stderr are connected to the screen, but stdin and stdout may be redirected to
files or pipes as described in Section 7.1.132
getchar and putchar can be defined in terms of getc , putc , stdin , and stdout as follows:
#define getchar()
#define putchar(c)
getc(stdin)
putc((c), stdout)
For formatted input or output of files, the functions fscanf and fprintf may be used. These
are identical to scanf and printf , except that the first argument is a file pointer that specifies
the file to be read or written; the format string is the second argument.
int fscanf(FILE *fp, char *format, ...)
int fprintf(FILE *fp, char *format, ...)
With these preliminaries out of the way, we are now in a position to write the program cat to
concatenate files. The design is one that has been found convenient for many programs. If
there are command-line arguments, they are interpreted as filenames, and processed in order. If
there are no arguments, the standard input is processed.
#include <stdio.h>
/* cat:
main(int
{
FILE
void
concatenate files, version 1 */
argc, char *argv[])
*fp;
filecopy(FILE *, FILE *)
if (argc == 1) /* no args; copy standard input */
filecopy(stdin, stdout);
else
while(--argc > 0)
if ((fp = fopen(*++argv, "r")) == NULL) {
printf("cat: can't open %s\n, *argv);
return 1;
} else {
filecopy(fp, stdout);
fclose(fp);
}
return 0;
}
/* filecopy: copy file ifp to file ofp */
void filecopy(FILE *ifp, FILE *ofp)
{
int c;
while ((c = getc(ifp)) != EOF)
putc(c, ofp);
}
The file pointers stdin and stdout are objects of type FILE * . They are constants, however,
not variables, so it is not possible to assign to them.
The function
int fclose(FILE *fp)
is the inverse of fopen , it breaks the connection between the file pointer and the external name
that was established by fopen , freeing the file pointer for another file. Since most operating
systems have some limit on the number of files that a program may have open simultaneously,
it's a good idea to free the file pointers when they are no longer needed, as we did in cat .
There is also another reason for fclose on an output file - it flushes the buffer in which putc
is collecting output. fclose is called automatically for each open file when a program
terminates normally. (You can close stdin and stdout if they are not needed. They can also
be reassigned by the library function freopen .)
7.6 Error Handling - Stderr and Exit133
The treatment of errors in cat is not ideal. The trouble is that if one of the files can't be
accessed for some reason, the diagnostic is printed at the end of the concatenated output. That
might be acceptable if the output is going to a screen, but not if it's going into a file or into
another program via a pipeline.
To handle this situation better, a second output stream, called stderr , is assigned to a
program in the same way that stdin and stdout are. Output written on stderr normally
appears on the screen even if the standard output is redirected.
Let us revise cat to write its error messages on the standard error.
#include <stdio.h>
/* cat:
main(int
{
FILE
void
char
concatenate files, version 2 */
argc, char *argv[])
*fp;
filecopy(FILE *, FILE *);
*prog = argv[0]; /* program name for errors */
if (argc == 1 ) /* no args; copy standard input */
filecopy(stdin, stdout);
else
while (--argc > 0)
if ((fp = fopen(*++argv, "r")) == NULL) {
fprintf(stderr, "%s: can't open %s\n",
prog, *argv);
exit(1);
} else {
filecopy(fp, stdout);
fclose(fp);
}
if (ferror(stdout)) {
fprintf(stderr, "%s: error writing stdout\n", prog);
exit(2);
}
exit(0);
}
The program signals errors in two ways. First, the diagnostic output produced by fprintf
goes to stderr , so it finds its way to the screen instead of disappearing down a pipeline or into
an output file. We included the program name, from argv[0] , in the message, so if this
program is used with others, the source of an error is identified.
Second, the program uses the standard library function exit , which terminates program
execution when it is called. The argument of exit is available to whatever process called this
one, so the success or failure of the program can be tested by another program that uses this
one as a sub-process. Conventionally, a return value of 0 signals that all is well; non-zero
values usually signal abnormal situations. exit calls fclose for each open output file, to flush
out any buffered output.
Within main , return expr is equivalent to exit (expr). exit has the advantage that it can be
called from other functions, and that calls to it can be found with a pattern-searching program
like those in Chapter 5.
The function ferror returns non-zero if an error occurred on the stream fp .ords in some input. Since the list ofon actual representation, but assure the compiler that all is well.
